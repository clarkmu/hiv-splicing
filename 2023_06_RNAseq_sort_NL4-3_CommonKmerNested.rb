# input is paired end nested D1 (idx_fp) common K-mer reads
#has a 10base PID
#uses only forward file to get splicing info
#and reverse file to get size class info
#finds unintended gag binding sites
#finds (and counts) unintended size class binding sites

#ref is reference sequence from post D1 cut to end of transcript
#this is the NL4-3 sequence
$ref = "GTGAGTACGCCAAAAATTTTGACTAGCGGAGGCTAGAAGGAGAGAGATGGGTGCGAGAGCGTCGGTATTAAGCGGGGGAGAATTAGATAAATGGGAAAAAATTCGGTTAAGGCCAGGGGGAAAGAAACAATATAAACTAAAACATATAGTATGGGCAAGCAGGGAGCTAGAACGATTCGCAGTTAATCCTGGCCTTTTAGAGACATCAGAAGGCTGTAGACAAATACTGGGACAGCTACAACCATCCCTTCAGACAGGATCAGAAGAACTTAGATCATTATATAATACAATAGCAGTCCTCTATTGTGTGCATCAAAGGATAGATGTAAAAGACACCAAGGAAGCCTTAGATAAGATAGAGGAAGAGCAAAACAAAAGTAAGAAAAAGGCACAGCAAGCAGCAGCTGACACAGGAAACAACAGCCAGGTCAGCCAAAATTACCCTATAGTGCAGAACCTCCAGGGGCAAATGGTACATCAGGCCATATCACCTAGAACTTTAAATGCATGGGTAAAAGTAGTAGAAGAGAAGGCTTTCAGCCCAGAAGTAATACCCATGTTTTCAGCATTATCAGAAGGAGCCACCCCACAAGATTTAAATACCATGCTAAACACAGTGGGGGGACATCAAGCAGCCATGCAAATGTTAAAAGAGACCATCAATGAGGAAGCTGCAGAATGGGATAGATTGCATCCAGTGCATGCAGGGCCTATTGCACCAGGCCAGATGAGAGAACCAAGGGGAAGTGACATAGCAGGAACTACTAGTACCCTTCAGGAACAAATAGGATGGATGACACATAATCCACCTATCCCAGTAGGAGAAATCTATAAAAGATGGATAATCCTGGGATTAAATAAAATAGTAAGAATGTATAGCCCTACCAGCATTCTGGACATAAGACAAGGACCAAAGGAACCCTTTAGAGACTATGTAGACCGATTCTATAAAACTCTAAGAGCCGAGCAAGCTTCACAAGAGGTAAAAAATTGGATGACAGAAACCTTGTTGGTCCAAAATGCGAACCCAGATTGTAAGACTATTTTAAAAGCATTGGGACCAGGAGCGACACTAGAAGAAATGATGACAGCATGTCAGGGAGTGGGGGGACCCGGCCATAAAGCAAGAGTTTTGGCTGAAGCAATGAGCCAAGTAACAAATCCAGCTACCATAATGATACAGAAAGGCAATTTTAGGAACCAAAGAAAGACTGTTAAGTGTTTCAATTGTGGCAAAGAAGGGCACATAGCCAAAAATTGCAGGGCCCCTAGGAAAAAGGGCTGTTGGAAATGTGGAAAGGAAGGACACCAAATGAAAGATTGTACTGAGAGACAGGCTAATTTTTTAGGGAAGATCTGGCCTTCCCACAAGGGAAGGCCAGGGAATTTTCTTCAGAGCAGACCAGAGCCAACAGCCCCACCAGAAGAGAGCTTCAGGTTTGGGGAAGAGACAACAACTCCCTCTCAGAAGCAGGAGCCGATAGACAAGGAACTGTATCCTTTAGCTTCCCTCAGATCACTCTTTGGCAGCGACCCCTCGTCACAATAAAGATAGGGGGGCAATTAAAGGAAGCTCTATTAGATACAGGAGCAGATGATACAGTATTAGAAGAAATGAATTTGCCAGGAAGATGGAAACCAAAAATGATAGGGGGAATTGGAGGTTTTATCAAAGTAAGACAGTATGATCAGATACTCATAGAAATCTGCGGACATAAAGCTATAGGTACAGTATTAGTAGGACCTACACCTGTCAACATAATTGGAAGAAATCTGTTGACTCAGATTGGCTGCACTTTAAATTTTCCCATTAGTCCTATTGAGACTGTACCAGTAAAATTAAAGCCAGGAATGGATGGCCCAAAAGTTAAACAATGGCCATTGACAGAAGAAAAAATAAAAGCATTAGTAGAAATTTGTACAGAAATGGAAAAGGAAGGAAAAATTTCAAAAATTGGGCCTGAAAATCCATACAATACTCCAGTATTTGCCATAAAGAAAAAAGACAGTACTAAATGGAGAAAATTAGTAGATTTCAGAGAACTTAATAAGAGAACTCAAGATTTCTGGGAAGTTCAATTAGGAATACCACATCCTGCAGGGTTAAAACAGAAAAAATCAGTAACAGTACTGGATGTGGGCGATGCATATTTTTCAGTTCCCTTAGATAAAGACTTCAGGAAGTATACTGCATTTACCATACCTAGTATAAACAATGAGACACCAGGGATTAGATATCAGTACAATGTGCTTCCACAGGGATGGAAAGGATCACCAGCAATATTCCAGTGTAGCATGACAAAAATCTTAGAGCCTTTTAGAAAACAAAATCCAGACATAGTCATCTATCAATACATGGATGATTTGTATGTAGGATCTGACTTAGAAATAGGGCAGCATAGAACAAAAATAGAGGAACTGAGACAACATCTGTTGAGGTGGGGATTTACCACACCAGACAAAAAACATCAGAAAGAACCTCCATTCCTTTGGATGGGTTATGAACTCCATCCTGATAAATGGACAGTACAGCCTATAGTGCTGCCAGAAAAGGACAGCTGGACTGTCAATGACATACAGAAATTAGTGGGAAAATTGAATTGGGCAAGTCAGATTTATGCAGGGATTAAAGTAAGGCAATTATGTAAACTTCTTAGGGGAACCAAAGCACTAACAGAAGTAGTACCACTAACAGAAGAAGCAGAGCTAGAACTGGCAGAAAACAGGGAGATTCTAAAAGAACCGGTACATGGAGTGTATTATGACCCATCAAAAGACTTAATAGCAGAAATACAGAAGCAGGGGCAAGGCCAATGGACATATCAAATTTATCAAGAGCCATTTAAAAATCTGAAAACAGGAAAATATGCAAGAATGAAGGGTGCCCACACTAATGATGTGAAACAATTAACAGAGGCAGTACAAAAAATAGCCACAGAAAGCATAGTAATATGGGGAAAGACTCCTAAATTTAAATTACCCATACAAAAGGAAACATGGGAAGCATGGTGGACAGAGTATTGGCAAGCCACCTGGATTCCTGAGTGGGAGTTTGTCAATACCCCTCCCTTAGTGAAGTTATGGTACCAGTTAGAGAAAGAACCCATAATAGGAGCAGAAACTTTCTATGTAGATGGGGCAGCCAATAGGGAAACTAAATTAGGAAAAGCAGGATATGTAACTGACAGAGGAAGACAAAAAGTTGTCCCCCTAACGGACACAACAAATCAGAAGACTGAGTTACAAGCAATTCATCTAGCTTTGCAGGATTCGGGATTAGAAGTAAACATAGTGACAGACTCACAATATGCATTGGGAATCATTCAAGCACAACCAGATAAGAGTGAATCAGAGTTAGTCAGTCAAATAATAGAGCAGTTAATAAAAAAGGAAAAAGTCTACCTGGCATGGGTACCAGCACACAAAGGAATTGGAGGAAATGAACAAGTAGATGGGTTGGTCAGTGCTGGAATCAGGAAAGTACTATTTTTAGATGGAATAGATAAGGCCCAAGAAGAACATGAGAAATATCACAGTAATTGGAGAGCAATGGCTAGTGATTTTAACCTACCACCTGTAGTAGCAAAAGAAATAGTAGCCAGCTGTGATAAATGTCAGCTAAAAGGGGAAGCCATGCATGGACAAGTAGACTGTAGCCCAGGAATATGGCAGCTAGATTGTACACATTTAGAAGGAAAAGTTATCTTGGTAGCAGTTCATGTAGCCAGTGGATATATAGAAGCAGAAGTAATTCCAGCAGAGACAGGGCAAGAAACAGCATACTTCCTCTTAAAATTAGCAGGAAGATGGCCAGTAAAAACAGTACATACAGACAATGGCAGCAATTTCACCAGTACTACAGTTAAGGCCGCCTGTTGGTGGGCGGGGATCAAGCAGGAATTTGGCATTCCCTACAATCCCCAAAGTCAAGGAGTAATAGAATCTATGAATAAAGAATTAAAGAAAATTATAGGACAGGTAAGAGATCAGGCTGAACATCTTAAGACAGCAGTACAAATGGCAGTATTCATCCACAATTTTAAAAGAAAAGGGGGGATTGGGGGGTACAGTGCAGGGGAAAGAATAGTAGACATAATAGCAACAGACATACAAACTAAAGAATTACAAAAACAAATTACAAAAATTCAAAATTTTCGGGTTTATTACAGGGACAGCAGAGATCCAGTTTGGAAAGGACCAGCAAAGCTCCTCTGGAAAGGTGAAGGGGCAGTAGTAATACAAGATAATAGTGACATAAAAGTAGTGCCAAGAAGAAAAGCAAAGATCATCAGGGATTATGGAAAACAGATGGCAGGTGATGATTGTGTGGCAAGTAGACAGGATGAGGATTAACACATGGAAAAGATTAGTAAAACACCATATGTATATTTCAAGGAAAGCTAAGGACTGGTTTTATAGACATCACTATGAAAGTACTAATCCAAAAATAAGTTCAGAAGTACACATCCCACTAGGGGATGCTAAATTAGTAATAACAACATATTGGGGTCTGCATACAGGAGAAAGAGACTGGCATTTGGGTCAGGGAGTCTCCATAGAATGGAGGAAAAAGAGATATAGCACACAAGTAGACCCTGACCTAGCAGACCAACTAATTCATCTGCACTATTTTGATTGTTTTTCAGAATCTGCTATAAGAAATACCATATTAGGACGTATAGTTAGTCCTAGGTGTGAATATCAAGCAGGACATAACAAGGTAGGATCTCTACAGTACTTGGCACTAGCAGCATTAATAAAACCAAAACAGATAAAGCCACCTTTGCCTAGTGTTAGGAAACTGACAGAGGACAGATGGAACAAGCCCCAGAAGACCAAGGGCCACAGAGGGAGCCATACAATGAATGGACACTAGAGCTTTTAGAGGAACTTAAGAGTGAAGCTGTTAGACATTTTCCTAGGATATGGCTCCATAACTTAGGACAACATATCTATGAAACTTACGGGGATACTTGGGCAGGAGTGGAAGCCATAATAAGAATTCTGCAACAACTGCTGTTTATCCATTTCAGAATTGGGTGTCGACATAGCAGAATAGGCGTTACTCGACAGAGGAGAGCAAGAAATGGAGCCAGTAGATCCTAGACTAGAGCCCTGGAAGCATCCAGGAAGTCAGCCTAAAACTGCTTGTACCAATTGCTATTGTAAAAAGTGTTGCTTTCATTGCCAAGTTTGTTTCATGACAAAAGCCTTAGGCATCTCCTATGGCAGGAAGAAGCGGAGACAGCGACGAAGAGCTCATCAGAACAGTCAGACTCATCAAGCTTCTCTATCAAAGCAGTAAGTAGTACATGTAATGCAACCTATAATAGTAGCAATAGTAGCATTAGTAGTAGCAATAATAATAGCAATAGTTGTGTGGTCCATAGTAATCATAGAATATAGGAAAATATTAAGACAAAGAAAAATAGACAGGTTAATTGATAGACTAATAGAAAGAGCAGAAGACAGTGGCAATGAGAGTGAAGGAGAAGTATCAGCACTTGTGGAGATGGGGGTGGAAATGGGGCACCATGCTCCTTGGGATATTGATGATCTGTAGTGCTACAGAAAAATTGTGGGTCACAGTCTATTATGGGGTACCTGTGTGGAAGGAAGCAACCACCACTCTATTTTGTGCATCAGATGCTAAAGCATATGATACAGAGGTACATAATGTTTGGGCCACACATGCCTGTGTACCCACAGACCCCAACCCACAAGAAGTAGTATTGGTAAATGTGACAGAAAATTTTAACATGTGGAAAAATGACATGGTAGAACAGATGCATGAGGATATAATCAGTTTATGGGATCAAAGCCTAAAGCCATGTGTAAAATTAACCCCACTCTGTGTTAGTTTAAAGTGCACTGATTTGAAGAATGATACTAATACCAATAGTAGTAGCGGGAGAATGATAATGGAGAAAGGAGAGATAAAAAACTGCTCTTTCAATATCAGCACAAGCATAAGAGATAAGGTGCAGAAAGAATATGCATTCTTTTATAAACTTGATATAGTACCAATAGATAATACCAGCTATAGGTTGATAAGTTGTAACACCTCAGTCATTACACAGGCCTGTCCAAAGGTATCCTTTGAGCCAATTCCCATACATTATTGTGCCCCGGCTGGTTTTGCGATTCTAAAATGTAATAATAAGACGTTCAATGGAACAGGACCATGTACAAATGTCAGCACAGTACAATGTACACATGGAATCAGGCCAGTAGTATCAACTCAACTGCTGTTAAATGGCAGTCTAGCAGAAGAAGATGTAGTAATTAGATCTGCCAATTTCACAGACAATGCTAAAACCATAATAGTACAGCTGAACACATCTGTAGAAATTAATTGTACAAGACCCAACAACAATACAAGAAAAAGTATCCGTATCCAGAGGGGACCAGGGAGAGCATTTGTTACAATAGGAAAAATAGGAAATATGAGACAAGCACATTGTAACATTAGTAGAGCAAAATGGAATGCCACTTTAAAACAGATAGCTAGCAAATTAAGAGAACAATTTGGAAATAATAAAACAATAATCTTTAAGCAATCCTCAGGAGGGGACCCAGAAATTGTAACGCACAGTTTTAATTGTGGAGGGGAATTTTTCTACTGTAATTCAACACAACTGTTTAATAGTACTTGGTTTAATAGTACTTGGAGTACTGAAGGGTCAAATAACACTGAAGGAAGTGACACAATCACACTCCCATGCAGAATAAAACAATTTATAAACATGTGGCAGGAAGTAGGAAAAGCAATGTATGCCCCTCCCATCAGTGGACAAATTAGATGTTCATCAAATATTACTGGGCTGCTATTAACAAGAGATGGTGGTAATAACAACAATGGGTCCGAGATCTTCAGACCTGGAGGAGGCGATATGAGGGACAATTGGAGAAGTGAATTATATAAATATAAAGTAGTAAAAATTGAACCATTAGGAGTAGCACCCACCAAGGCAAAGAGAAGAGTGGTGCAGAGAGAAAAAAGAGCAGTGGGAATAGGAGCTTTGTTCCTTGGGTTCTTGGGAGCAGCAGGAAGCACTATGGGCTGCACGTCAATGACGCTGACGGTACAGGCCAGACAATTATTGTCTGATATAGTGCAGCAGCAGAACAATTTGCTGAGGGCTATTGAGGCGCAACAGCATCTGTTGCAACTCACAGTCTGGGGCATCAAACAGCTCCAGGCAAGAATCCTGGCTGTGGAAAGATACCTAAAGGATCAACAGCTCCTGGGGATTTGGGGTTGCTCTGGAAAACTCATTTGCACCACTGCTGTGCCTTGGAATGCTAGTTGGAGTAATAAATCTCTGGAACAGATTTGGAATAACATGACCTGGATGGAGTGGGACAGAGAAATTAACAATTACACAAGCTTAATACACTCCTTAATTGAAGAATCGCAAAACCAGCAAGAAAAGAATGAACAAGAATTATTGGAATTAGATAAATGGGCAAGTTTGTGGAATTGGTTTAACATAACAAATTGGCTGTGGTATATAAAATTATTCATAATGATAGTAGGAGGCTTGGTAGGTTTAAGAATAGTTTTTGCTGTACTTTCTATAGTGAATAGAGTTAGGCAGGGATATTCACCATTATCGTTTCAGACCCACCTCCCAATCCCGAGGGGACCCGACAGGCCCGAAGGAATAGAAGAAGAAGGTGGAGAGAGAGACAGAGACAGATCCATTCGATTAGTGAACGGATCCTTAGCACTTATCTGGGACGATCTGCGGAGCCTGTGCCTCTTCAGCTACCACCGCTTGAGAGACTTACTCTTGATTGTAACGAGGATTGTGGAACTTCTGGGACGCAGGGGGTGGGAAGCCCTCAAATATTGGTGGAATCTCCTACAGTATTGGAGTCAGGAACTAAAGAATAGTGCTGTTAACTTGCTCAATGCCACAGCCATAGCAGTAGCTGAGGGGACAGATAGGGTTATAGAAGTATTACAAGCAGCTTATAGAGCTATTCGCCACATACCTAGAAGAATAAGACAGGGCTTGGAAAGGATTTTGCTATAAGATGGGTGGCAAGTGGTCAAAAAGTAGTGTGATTGGATGGCCTGCTGTAAGGGAAAGAATGAGACGAGCTGAGCCAGCAGCAGATGGGGTGGGAGCAGTATCTCGAGACCTAGAAAAACATGGAGCAATCACAAGTAGCAATACAGCAGCTAACAATGCTGCTTGTGCCTGGCTAGAAGCACAAGAGGAGGAAGAGGTGGGTTTTCCAGTCACACCTCAGGTACCTTTAAGACCAATGACTTACAAGGCAGCTGTAGATCTTAGCCACTTTTTAAAAGAAAAGGGGGGACTGGAAGGGCTAATTCACTCCCAAAGAAGACAAGATATCCTTGATCTGTGGATCTACCACACACAAGGCTACTTCCCTGATTGGCAGAACTACACACCAGGGCCAGGGGTCAGATATCCACTGACCTTTGGATGGTGCTACAAGCTAGTACCAGTTGAGCCAGATAAGGTAGAAGAGGCCAATAAAGGAGAGAACACCAGCTTGTTACACCCTGTGAGCCTGCATGGAATGGATGACCCTGAGAGAGAAGTGTTAGAGTGGAGGTTTGACAGCCGCCTAGCATTTCATCACGTGGCCCGAGAGCTGCATCCGGAGTACTTCAAGAACTGCTGACATCGAGCTTGCTACAAGGGACTTTCCGCTGGGGACTTTCCAGGGAGGCGTGGCCTGGGCGGGACTGGGGAGTGGCGAGCCCTCAGATGCTGCATATAAGCAGCTGCTTTTTGCCTGTACTGGGTCTCTCTGGTTAGACCAGATCTGAGCCTGGGAGCTCTCTGGCTAACTAGGGAACCCACTGCTTAAGCCTCAATAAAGCTTGCCTTGAGTGCTTCA"

#this is the RC of $ref, from the end of the transcript to D1
$rc = "TGAAGCACTCAAGGCAAGCTTTATTGAGGCTTAAGCAGTGGGTTCCCTAGTTAGCCAGAGAGCTCCCAGGCTCAGATCTGGTCTAACCAGAGAGACCCAGTACAGGCAAAAAGCAGCTGCTTATATGCAGCATCTGAGGGCTCGCCACTCCCCAGTCCCGCCCAGGCCACGCCTCCCTGGAAAGTCCCCAGCGGAAAGTCCCTTGTAGCAAGCTCGATGTCAGCAGTTCTTGAAGTACTCCGGATGCAGCTCTCGGGCCACGTGATGAAATGCTAGGCGGCTGTCAAACCTCCACTCTAACACTTCTCTCTCAGGGTCATCCATTCCATGCAGGCTCACAGGGTGTAACAAGCTGGTGTTCTCTCCTTTATTGGCCTCTTCTACCTTATCTGGCTCAACTGGTACTAGCTTGTAGCACCATCCAAAGGTCAGTGGATATCTGACCCCTGGCCCTGGTGTGTAGTTCTGCCAATCAGGGAAGTAGCCTTGTGTGTGGTAGATCCACAGATCAAGGATATCTTGTCTTCTTTGGGAGTGAATTAGCCCTTCCAGTCCCCCCTTTTCTTTTAAAAAGTGGCTAAGATCTACAGCTGCCTTGTAAGTCATTGGTCTTAAAGGTACCTGAGGTGTGACTGGAAAACCCACCTCTTCCTCCTCTTGTGCTTCTAGCCAGGCACAAGCAGCATTGTTAGCTGCTGTATTGCTACTTGTGATTGCTCCATGTTTTTCTAGGTCTCGAGATACTGCTCCCACCCCATCTGCTGCTGGCTCAGCTCGTCTCATTCTTTCCCTTACAGCAGGCCATCCAATCACACTACTTTTTGACCACTTGCCACCCATCTTATAGCAAAATCCTTTCCAAGCCCTGTCTTATTCTTCTAGGTATGTGGCGAATAGCTCTATAAGCTGCTTGTAATACTTCTATAACCCTATCTGTCCCCTCAGCTACTGCTATGGCTGTGGCATTGAGCAAGTTAACAGCACTATTCTTTAGTTCCTGACTCCAATACTGTAGGAGATTCCACCAATATTTGAGGGCTTCCCACCCCCTGCGTCCCAGAAGTTCCACAATCCTCGTTACAATCAAGAGTAAGTCTCTCAAGCGGTGGTAGCTGAAGAGGCACAGGCTCCGCAGATCGTCCCAGATAAGTGCTAAGGATCCGTTCACTAATCGAATGGATCTGTCTCTGTCTCTCTCTCCACCTTCTTCTTCTATTCCTTCGGGCCTGTCGGGTCCCCTCGGGATTGGGAGGTGGGTCTGAAACGATAATGGTGAATATCCCTGCCTAACTCTATTCACTATAGAAAGTACAGCAAAAACTATTCTTAAACCTACCAAGCCTCCTACTATCATTATGAATAATTTTATATACCACAGCCAATTTGTTATGTTAAACCAATTCCACAAACTTGCCCATTTATCTAATTCCAATAATTCTTGTTCATTCTTTTCTTGCTGGTTTTGCGATTCTTCAATTAAGGAGTGTATTAAGCTTGTGTAATTGTTAATTTCTCTGTCCCACTCCATCCAGGTCATGTTATTCCAAATCTGTTCCAGAGATTTATTACTCCAACTAGCATTCCAAGGCACAGCAGTGGTGCAAATGAGTTTTCCAGAGCAACCCCAAATCCCCAGGAGCTGTTGATCCTTTAGGTATCTTTCCACAGCCAGGATTCTTGCCTGGAGCTGTTTGATGCCCCAGACTGTGAGTTGCAACAGATGCTGTTGCGCCTCAATAGCCCTCAGCAAATTGTTCTGCTGCTGCACTATATCAGACAATAATTGTCTGGCCTGTACCGTCAGCGTCATTGACGTGCAGCCCATAGTGCTTCCTGCTGCTCCCAAGAACCCAAGGAACAAAGCTCCTATTCCCACTGCTCTTTTTTCTCTCTGCACCACTCTTCTCTTTGCCTTGGTGGGTGCTACTCCTAATGGTTCAATTTTTACTACTTTATATTTATATAATTCACTTCTCCAATTGTCCCTCATATCGCCTCCTCCAGGTCTGAAGATCTCGGACCCATTGTTGTTATTACCACCATCTCTTGTTAATAGCAGCCCAGTAATATTTGATGAACATCTAATTTGTCCACTGATGGGAGGGGCATACATTGCTTTTCCTACTTCCTGCCACATGTTTATAAATTGTTTTATTCTGCATGGGAGTGTGATTGTGTCACTTCCTTCAGTGTTATTTGACCCTTCAGTACTCCAAGTACTATTAAACCAAGTACTATTAAACAGTTGTGTTGAATTACAGTAGAAAAATTCCCCTCCACAATTAAAACTGTGCGTTACAATTTCTGGGTCCCCTCCTGAGGATTGCTTAAAGATTATTGTTTTATTATTTCCAAATTGTTCTCTTAATTTGCTAGCTATCTGTTTTAAAGTGGCATTCCATTTTGCTCTACTAATGTTACAATGTGCTTGTCTCATATTTCCTATTTTTCCTATTGTAACAAATGCTCTCCCTGGTCCCCTCTGGATACGGATACTTTTTCTTGTATTGTTGTTGGGTCTTGTACAATTAATTTCTACAGATGTGTTCAGCTGTACTATTATGGTTTTAGCATTGTCTGTGAAATTGGCAGATCTAATTACTACATCTTCTTCTGCTAGACTGCCATTTAACAGCAGTTGAGTTGATACTACTGGCCTGATTCCATGTGTACATTGTACTGTGCTGACATTTGTACATGGTCCTGTTCCATTGAACGTCTTATTATTACATTTTAGAATCGCAAAACCAGCCGGGGCACAATAATGTATGGGAATTGGCTCAAAGGATACCTTTGGACAGGCCTGTGTAATGACTGAGGTGTTACAACTTATCAACCTATAGCTGGTATTATCTATTGGTACTATATCAAGTTTATAAAAGAATGCATATTCTTTCTGCACCTTATCTCTTATGCTTGTGCTGATATTGAAAGAGCAGTTTTTTATCTCTCCTTTCTCCATTATCATTCTCCCGCTACTACTATTGGTATTAGTATCATTCTTCAAATCAGTGCACTTTAAACTAACACAGAGTGGGGTTAATTTTACACATGGCTTTAGGCTTTGATCCCATAAACTGATTATATCCTCATGCATCTGTTCTACCATGTCATTTTTCCACATGTTAAAATTTTCTGTCACATTTACCAATACTACTTCTTGTGGGTTGGGGTCTGTGGGTACACAGGCATGTGTGGCCCAAACATTATGTACCTCTGTATCATATGCTTTAGCATCTGATGCACAAAATAGAGTGGTGGTTGCTTCCTTCCACACAGGTACCCCATAATAGACTGTGACCCACAATTTTTCTGTAGCACTACAGATCATCAATATCCCAAGGAGCATGGTGCCCCATTTCCACCCCCATCTCCACAAGTGCTGATACTTCTCCTTCACTCTCATTGCCACTGTCTTCTGCTCTTTCTATTAGTCTATCAATTAACCTGTCTATTTTTCTTTGTCTTAATATTTTCCTATATTCTATGATTACTATGGACCACACAACTATTGCTATTATTATTGCTACTACTAATGCTACTATTGCTACTATTATAGGTTGCATTACATGTACTACTTACTGCTTTGATAGAGAAGCTTGATGAGTCTGACTGTTCTGATGAGCTCTTCGTCGCTGTCTCCGCTTCTTCCTGCCATAGGAGATGCCTAAGGCTTTTGTCATGAAACAAACTTGGCAATGAAAGCAACACTTTTTACAATAGCAATTGGTACAAGCAGTTTTAGGCTGACTTCCTGGATGCTTCCAGGGCTCTAGTCTAGGATCTACTGGCTCCATTTCTTGCTCTCCTCTGTCGAGTAACGCCTATTCTGCTATGTCGACACCCAATTCTGAAATGGATAAACAGCAGTTGTTGCAGAATTCTTATTATGGCTTCCACTCCTGCCCAAGTATCCCCGTAAGTTTCATAGATATGTTGTCCTAAGTTATGGAGCCATATCCTAGGAAAATGTCTAACAGCTTCACTCTTAAGTTCCTCTAAAAGCTCTAGTGTCCATTCATTGTATGGCTCCCTCTGTGGCCCTTGGTCTTCTGGGGCTTGTTCCATCTGTCCTCTGTCAGTTTCCTAACACTAGGCAAAGGTGGCTTTATCTGTTTTGGTTTTATTAATGCTGCTAGTGCCAAGTACTGTAGAGATCCTACCTTGTTATGTCCTGCTTGATATTCACACCTAGGACTAACTATACGTCCTAATATGGTATTTCTTATAGCAGATTCTGAAAAACAATCAAAATAGTGCAGATGAATTAGTTGGTCTGCTAGGTCAGGGTCTACTTGTGTGCTATATCTCTTTTTCCTCCATTCTATGGAGACTCCCTGACCCAAATGCCAGTCTCTTTCTCCTGTATGCAGACCCCAATATGTTGTTATTACTAATTTAGCATCCCCTAGTGGGATGTGTACTTCTGAACTTATTTTTGGATTAGTACTTTCATAGTGATGTCTATAAAACCAGTCCTTAGCTTTCCTTGAAATATACATATGGTGTTTTACTAATCTTTTCCATGTGTTAATCCTCATCCTGTCTACTTGCCACACAATCATCACCTGCCATCTGTTTTCCATAATCCCTGATGATCTTTGCTTTTCTTCTTGGCACTACTTTTATGTCACTATTATCTTGTATTACTACTGCCCCTTCACCTTTCCAGAGGAGCTTTGCTGGTCCTTTCCAAACTGGATCTCTGCTGTCCCTGTAATAAACCCGAAAATTTTGAATTTTTGTAATTTGTTTTTGTAATTCTTTAGTTTGTATGTCTGTTGCTATTATGTCTACTATTCTTTCCCCTGCACTGTACCCCCCAATCCCCCCTTTTCTTTTAAAATTGTGGATGAATACTGCCATTTGTACTGCTGTCTTAAGATGTTCAGCCTGATCTCTTACCTGTCCTATAATTTTCTTTAATTCTTTATTCATAGATTCTATTACTCCTTGACTTTGGGGATTGTAGGGAATGCCAAATTCCTGCTTGATCCCCGCCCACCAACAGGCGGCCTTAACTGTAGTACTGGTGAAATTGCTGCCATTGTCTGTATGTACTGTTTTTACTGGCCATCTTCCTGCTAATTTTAAGAGGAAGTATGCTGTTTCTTGCCCTGTCTCTGCTGGAATTACTTCTGCTTCTATATATCCACTGGCTACATGAACTGCTACCAAGATAACTTTTCCTTCTAAATGTGTACAATCTAGCTGCCATATTCCTGGGCTACAGTCTACTTGTCCATGCATGGCTTCCCCTTTTAGCTGACATTTATCACAGCTGGCTACTATTTCTTTTGCTACTACAGGTGGTAGGTTAAAATCACTAGCCATTGCTCTCCAATTACTGTGATATTTCTCATGTTCTTCTTGGGCCTTATCTATTCCATCTAAAAATAGTACTTTCCTGATTCCAGCACTGACCAACCCATCTACTTGTTCATTTCCTCCAATTCCTTTGTGTGCTGGTACCCATGCCAGGTAGACTTTTTCCTTTTTTATTAACTGCTCTATTATTTGACTGACTAACTCTGATTCACTCTTATCTGGTTGTGCTTGAATGATTCCCAATGCATATTGTGAGTCTGTCACTATGTTTACTTCTAATCCCGAATCCTGCAAAGCTAGATGAATTGCTTGTAACTCAGTCTTCTGATTTGTTGTGTCCGTTAGGGGGACAACTTTTTGTCTTCCTCTGTCAGTTACATATCCTGCTTTTCCTAATTTAGTTTCCCTATTGGCTGCCCCATCTACATAGAAAGTTTCTGCTCCTATTATGGGTTCTTTCTCTAACTGGTACCATAACTTCACTAAGGGAGGGGTATTGACAAACTCCCACTCAGGAATCCAGGTGGCTTGCCAATACTCTGTCCACCATGCTTCCCATGTTTCCTTTTGTATGGGTAATTTAAATTTAGGAGTCTTTCCCCATATTACTATGCTTTCTGTGGCTATTTTTTGTACTGCCTCTGTTAATTGTTTCACATCATTAGTGTGGGCACCCTTCATTCTTGCATATTTTCCTGTTTTCAGATTTTTAAATGGCTCTTGATAAATTTGATATGTCCATTGGCCTTGCCCCTGCTTCTGTATTTCTGCTATTAAGTCTTTTGATGGGTCATAATACACTCCATGTACCGGTTCTTTTAGAATCTCCCTGTTTTCTGCCAGTTCTAGCTCTGCTTCTTCTGTTAGTGGTACTACTTCTGTTAGTGCTTTGGTTCCCCTAAGAAGTTTACATAATTGCCTTACTTTAATCCCTGCATAAATCTGACTTGCCCAATTCAATTTTCCCACTAATTTCTGTATGTCATTGACAGTCCAGCTGTCCTTTTCTGGCAGCACTATAGGCTGTACTGTCCATTTATCAGGATGGAGTTCATAACCCATCCAAAGGAATGGAGGTTCTTTCTGATGTTTTTTGTCTGGTGTGGTAAATCCCCACCTCAACAGATGTTGTCTCAGTTCCTCTATTTTTGTTCTATGCTGCCCTATTTCTAAGTCAGATCCTACATACAAATCATCCATGTATTGATAGATGACTATGTCTGGATTTTGTTTTCTAAAAGGCTCTAAGATTTTTGTCATGCTACACTGGAATATTGCTGGTGATCCTTTCCATCCCTGTGGAAGCACATTGTACTGATATCTAATCCCTGGTGTCTCATTGTTTATACTAGGTATGGTAAATGCAGTATACTTCCTGAAGTCTTTATCTAAGGGAACTGAAAAATATGCATCGCCCACATCCAGTACTGTTACTGATTTTTTCTGTTTTAACCCTGCAGGATGTGGTATTCCTAATTGAACTTCCCAGAAATCTTGAGTTCTCTTATTAAGTTCTCTGAAATCTACTAATTTTCTCCATTTAGTACTGTCTTTTTTCTTTATGGCAAATACTGGAGTATTGTATGGATTTTCAGGCCCAATTTTTGAAATTTTTCCTTCCTTTTCCATTTCTGTACAAATTTCTACTAATGCTTTTATTTTTTCTTCTGTCAATGGCCATTGTTTAACTTTTGGGCCATCCATTCCTGGCTTTAATTTTACTGGTACAGTCTCAATAGGACTAATGGGAAAATTTAAAGTGCAGCCAATCTGAGTCAACAGATTTCTTCCAATTATGTTGACAGGTGTAGGTCCTACTAATACTGTACCTATAGCTTTATGTCCGCAGATTTCTATGAGTATCTGATCATACTGTCTTACTTTGATAAAACCTCCAATTCCCCCTATCATTTTTGGTTTCCATCTTCCTGGCAAATTCATTTCTTCTAATACTGTATCATCTGCTCCTGTATCTAATAGAGCTTCCTTTAATTGCCCCCCTATCTTTATTGTGACGAGGGGTCGCTGCCAAAGAGTGATCTGAGGGAAGCTAAAGGATACAGTTCCTTGTCTATCGGCTCCTGCTTCTGAGAGGGAGTTGTTGTCTCTTCCCCAAACCTGAAGCTCTCTTCTGGTGGGGCTGTTGGCTCTGGTCTGCTCTGAAGAAAATTCCCTGGCCTTCCCTTGTGGGAAGGCCAGATCTTCCCTAAAAAATTAGCCTGTCTCTCAGTACAATCTTTCATTTGGTGTCCTTCCTTTCCACATTTCCAACAGCCCTTTTTCCTAGGGGCCCTGCAATTTTTGGCTATGTGCCCTTCTTTGCCACAATTGAAACACTTAACAGTCTTTCTTTGGTTCCTAAAATTGCCTTTCTGTATCATTATGGTAGCTGGATTTGTTACTTGGCTCATTGCTTCAGCCAAAACTCTTGCTTTATGGCCGGGTCCCCCCACTCCCTGACATGCTGTCATCATTTCTTCTAGTGTCGCTCCTGGTCCCAATGCTTTTAAAATAGTCTTACAATCTGGGTTCGCATTTTGGACCAACAAGGTTTCTGTCATCCAATTTTTTACCTCTTGTGAAGCTTGCTCGGCTCTTAGAGTTTTATAGAATCGGTCTACATAGTCTCTAAAGGGTTCCTTTGGTCCTTGTCTTATGTCCAGAATGCTGGTAGGGCTATACATTCTTACTATTTTATTTAATCCCAGGATTATCCATCTTTTATAGATTTCTCCTACTGGGATAGGTGGATTATGTGTCATCCATCCTATTTGTTCCTGAAGGGTACTAGTAGTTCCTGCTATGTCACTTCCCCTTGGTTCTCTCATCTGGCCTGGTGCAATAGGCCCTGCATGCACTGGATGCAATCTATCCCATTCTGCAGCTTCCTCATTGATGGTCTCTTTTAACATTTGCATGGCTGCTTGATGTCCCCCCACTGTGTTTAGCATGGTATTTAAATCTTGTGGGGTGGCTCCTTCTGATAATGCTGAAAACATGGGTATTACTTCTGGGCTGAAAGCCTTCTCTTCTACTACTTTTACCCATGCATTTAAAGTTCTAGGTGATATGGCCTGATGTACCATTTGCCCCTGGAGGTTCTGCACTATAGGGTAATTTTGGCTGACCTGGCTGTTGTTTCCTGTGTCAGCTGCTGCTTGCTGTGCCTTTTTCTTACTTTTGTTTTGCTCTTCCTCTATCTTATCTAAGGCTTCCTTGGTGTCTTTTACATCTATCCTTTGATGCACACAATAGAGGACTGCTATTGTATTATATAATGATCTAAGTTCTTCTGATCCTGTCTGAAGGGATGGTTGTAGCTGTCCCAGTATTTGTCTACAGCCTTCTGATGTCTCTAAAAGGCCAGGATTAACTGCGAATCGTTCTAGCTCCCTGCTTGCCCATACTATATGTTTTAGTTTATATTGTTTCTTTCCCCCTGGCCTTAACCGAATTTTTTCCCATTTATCTAATTCTCCCCCGCTTAATACCGACGCTCTCGCACCCATCTCTCTCCTTCTAGCCTCCGCTAGTCAAAATTTTTGGCGTACTCAC"
#this is the RC of the 600 bases after D1
$rcRef = "TTTAAATCTTGTGGGGTGGCTCCTTCTGATAATGCTGAAAACATGGGTATTACTTCTGGGCTGAAAGCCTTCTCTTCTACTACTTTTACCCATGCATTTAAAGTTCTAGGTGATATGGCCTGATGTACCATTTGCCCCTGGAGGTTCTGCACTATAGGGTAATTTTGGCTGACCTGGCTGTTGTTTCCTGTGTCAGCTGCTGCTTGCTGTGCCTTTTTCTTACTTTTGTTTTGCTCTTCCTCTATCTTATCTAAGGCTTCCTTGGTGTCTTTTACATCTATCCTTTGATGCACACAATAGAGGACTGCTATTGTATTATATAATGATCTAAGTTCTTCTGATCCTGTCTGAAGGGATGGTTGTAGCTGTCCCAGTATTTGTCTACAGCCTTCTGATGTCTCTAAAAGGCCAGGATTAACTGCGAATCGTTCTAGCTCCCTGCTTGCCCATACTATATGTTTTAGTTTATATTGTTTCTTTCCCCCTGGCCTTAACCGAATTTTTTCCCATTTATCTAATTCTCCCCCGCTTAATACCGACGCTCTCGCACCCATCTCTCTCCTTCTAGCCTCCGCTAGTCAAAATTTTTGGCGTACTCAC"

#this is the RC of the 600 bases after A7
$rcComplete = "TGTGCTTCTAGCCAGGCACAAGCAGCATTGTTAGCTGCTGTATTGCTACTTGTGATTGCTCCATGTTTTTCTAGGTCTCGAGATACTGCTCCCACCCCATCTGCTGCTGGCTCAGCTCGTCTCATTCTTTCCCTTACAGCAGGCCATCCAATCACACTACTTTTTGACCACTTGCCACCCATCTTATAGCAAAATCCTTTCCAAGCCCTGTCTTATTCTTCTAGGTATGTGGCGAATAGCTCTATAAGCTGCTTGTAATACTTCTATAACCCTATCTGTCCCCTCAGCTACTGCTATGGCTGTGGCATTGAGCAAGTTAACAGCACTATTCTTTAGTTCCTGACTCCAATACTGTAGGAGATTCCACCAATATTTGAGGGCTTCCCACCCCCTGCGTCCCAGAAGTTCCACAATCCTCGTTACAATCAAGAGTAAGTCTCTCAAGCGGTGGTAGCTGAAGAGGCACAGGCTCCGCAGATCGTCCCAGATAAGTGCTAAGGATCCGTTCACTAATCGAATGGATCTGTCTCTGTCTCTCTCTCCACCTTCTTCTTCTATTCCTTCGGGCCTGTCGGGTCCCCTCGGGATTGGGAGGTGGGT"

#this is the RC of the 600 bases after D4
$rcIncomp = "TATTGGTATTAGTATCATTCTTCAAATCAGTGCACTTTAAACTAACACAGAGTGGGGTTAATTTTACACATGGCTTTAGGCTTTGATCCCATAAACTGATTATATCCTCATGCATCTGTTCTACCATGTCATTTTTCCACATGTTAAAATTTTCTGTCACATTTACCAATACTACTTCTTGTGGGTTGGGGTCTGTGGGTACACAGGCATGTGTGGCCCAAACATTATGTACCTCTGTATCATATGCTTTAGCATCTGATGCACAAAATAGAGTGGTGGTTGCTTCCTTCCACACAGGTACCCCATAATAGACTGTGACCCACAATTTTTCTGTAGCACTACAGATCATCAATATCCCAAGGAGCATGGTGCCCCATTTCCACCCCCATCTCCACAAGTGCTGATACTTCTCCTTCACTCTCATTGCCACTGTCTTCTGCTCTTTCTATTAGTCTATCAATTAACCTGTCTATTTTTCTTTGTCTTAATATTTTCCTATATTCTATGATTACTATGGACCACACAACTATTGCTATTATTATTGCTACTACTAATGCTACTATTGCTACTATTATAGGTTGCATTACATGTACTACTTAC"

#TTTCCCACCCCC / TTTTCCACCCCC is the degenerate common K-mer cDNA primer

#returns the reverse complement of a DNA sequence
def returnRC(dna_sequence)
    # Reverse the sequence
    rev = dna_sequence.reverse()
    reverse_complement_strand = ''
    # Complement each base ( A <=> T and C <=> G )
    rev.each_char do |ch|
        if ( ch == "A" || ch == "a" )
          reverse_complement_strand += 'T'
        elsif ( ch == "C" || ch == "c" )
          reverse_complement_strand += 'G'
        elsif ( ch == "G" || ch == "g" )
          reverse_complement_strand += 'C'
        elsif ( ch == "T" || ch == "t" )
          reverse_complement_strand += 'A'
        end
    end

    return reverse_complement_strand
end



#finds the index of an unknown acceptor sequence, adapted to be the FL genome index
def identifyAcceptor(unknownAcceptorSequence) #the unknownAcceptor Sequence is 10 bases long
    #ref is reference sequence from post D1 cut to end of transcript
    #this is the NL4-3 sequence
    if searchIdx = $ref.index(unknownAcceptorSequence)
        actualAcceptorIndex = searchIdx + 743 + 1 #index of post D1, +1 because Ruby indexes at 0
        return actualAcceptorIndex
    end
    return nil

end

#returns t/f if edit distance is less than maxAllowedEditDistance
def closeEnough?(sequence, reference, maxAllowedEditDistance)

    scoreTable = []

    if sequence == nil
        return false
    end

    rl= reference.length()
    sl = sequence.length()
    #    puts l, s
    (sl + 1).times do
        scoreTable << []
    end


    #reference is across the top
    #test sequence is on the left column
    #initialize score table
    #initialize top row
    for xidx in 0..rl
        scoreTable[0] << xidx
    end
    #initialize first column
    for xidx in 1..sl
        scoreTable[xidx] << xidx
    end
    #print scoreTable



    #and now we come to the actual alignment
    for sequenceIdx in 0...sl # does NOT include final length #these are the rows
        for referenceIdx in 0...rl #these are the columns
            #score table reference is across the top, test sequence is down the left side


            diag = scoreTable[sequenceIdx][referenceIdx]
            up = scoreTable[sequenceIdx][referenceIdx + 1]
            left = scoreTable[sequenceIdx + 1][referenceIdx]
            if reference[referenceIdx] == sequence[sequenceIdx] # it's a perfect match
                #append the values to the reference index row array
                minScore = [diag, left + 1, up + 1].min
                #puts "exact match"
                #puts "diag: ", (diag)
                #puts "left + 1: ", (left + 1)
                #puts "up + 1: ", (up + 1)
                scoreTable[sequenceIdx + 1] << minScore
                #puts "referenceIdx: ", referenceIdx
                #puts "sequenceIdx: ", sequenceIdx
                #prettyPrintScoreArray(scoreTable, sequence,reference)
                else #they don't match, cost to mutate = 1, cost to insert or delete = 1
                minScore = [diag + 1, left + 1, up + 1].min
                #puts "don't match"
                #puts "diag + 1: ", (diag + 1)
                #puts "left + 1: ", (left + 1)
                #puts "up + 1: ", (up + 1)
                scoreTable[sequenceIdx + 1] << minScore

                #prettyPrintScoreArray(scoreTable, sequence,reference)
            end
            #prettyPrintPathArray(pathTable, sequence, reference)
        end
    end
    #print scoreTable
    editDistance = scoreTable[sl][rl]
    #puts "editDistanceLine64:\t", editDistance
    if editDistance <= maxAllowedEditDistance
        return true
        else
        return false
    end
end



def sort_forward_sequence(sequence)
    spliceMap = []
    l = sequence.length
    #look for for search sequences of forward primer idx_fp
    if sequence[4, 8].include?('TGCTGA')
        fp_idx = sequence[4, 8].index('TGCTGA')
        fp_index = fp_idx + 4 #start of fp
        #now look for closeEnough? options
        elsif closeEnough?(sequence[4, 9], 'TGCTGAAGC', 1 )
        fp_index = 4
        else #not finding forward primer
        return spliceMap
    end

    # remove forward primer dimers
    if sequence[10, 50].include?('CTGAACT') #chunk of Illumina sequence in rps
        spliceMap << "PrimerDimer"
        return spliceMap
    end


    #look here for D1 sequence
    if sequence[(fp_index + 33)..50].include?('CGACTG')#if D1 sequence is in the right location
        idx = sequence.index('CGACTG',fp_index + 33) #search for D1 sequence
        else
        for d in (fp_index + 30)..50 #back up three spaces and expand the search sequence to 9 bases
            if closeEnough?(sequence[d, 9], 'CGGCGACTG', 1) #NL4-3 D
                idx = d + 3
                break
            end
        end

    end
    if idx == nil #failed to find preD1 sequence
        return spliceMap
        #look for D1-Ax splices
        elsif sequence[(idx + 6), 6].eql?("GTGAGT")  and (sequence[(idx + 6), 10].eql?("GTGAGTACGC") or closeEnough?(sequence[(idx + 6), 16], "GTGAGTACGCCAAAAA", 2))#no splice acceptor- has sequence after D1, is unspliced misprime or splices later than D1
        spliceMap << "unspliced"
        #puts sequence[(idx + 6), 20] #it's really unspliced
        #full length RNA
        return spliceMap

        elsif sequence[(idx + 6), 6].eql?('GGACAG') #A1  for NL4-3
        spliceMap << "D1" << "A1"
        return spliceMap <<  sort_forward_sequence_A1(sequence[(idx + 12)..l])


        elsif sequence[(idx + 6), 6].eql?('AATCTG') #A2
        spliceMap << "D1" << "A2"
        return spliceMap << sort_forward_sequence_A2(sequence[(idx + 12)..l])


        elsif sequence[(idx + 6), 6].eql?('AATTGG')  #A3
        spliceMap << "D1" << "A3"
        return spliceMap


        elsif sequence[(idx + 6), 6].eql?('TGTTGC') #A4d
        spliceMap << "D1" << "A4d"
        return spliceMap


        elsif sequence[(idx + 6), 6].eql?('TTTGTT') #A4c
        spliceMap << "D1" << "A4c"
        return spliceMap

        elsif sequence[(idx + 6), 6].eql?('CCTTAG') #A4a
        spliceMap << "D1" << "A4a"
        return spliceMap


        elsif sequence[(idx + 6), 6].eql?('GCATCT') #A4b
        spliceMap << "D1" << "A4b"
        return spliceMap

        elsif sequence[(idx + 6), 6].eql?('GAAGAA') #A5
        spliceMap << "D1" << "A5a"
        return spliceMap

        elsif sequence[(idx + 6), 6].eql?('AAGCGG') #A5b
        spliceMap << "D1" << "A5b"
        return spliceMap

        elsif sequence[(idx + 6), 6].eql?('ACCCAC') #A7
        spliceMap << "D1" << "A7"
        return spliceMap

        ######### acceptors with mutations - use closeEnough?()
        elsif closeEnough?(sequence[(idx + 6), 9], 'GGACAGCAG', 1) #A1  for NL4-3
        #puts "line 192"
        spliceMap << "D1" << "A1"
        return spliceMap << sort_forward_sequence_A1(sequence[(idx + 12)..l])

        elsif closeEnough?(sequence[(idx + 6), 9], 'AATCTGCTA', 1) #A2
        #puts "line 208"
        spliceMap << "D1" << "A2"
        return spliceMap << sort_forward_sequence_A2(sequence[(idx + 12)..l])


        elsif closeEnough?(sequence[(idx + 6), 9], 'AATTGGGTG', 1)  #A3
        #puts "line 224"
        spliceMap << "D1" << "A3"
        return spliceMap


        elsif closeEnough?(sequence[(idx + 6), 9], 'TGTTGCTTT', 1) #A4d
        #puts "line 240"
        spliceMap << "D1" << "A4d"
        return spliceMap


        elsif closeEnough?(sequence[(idx + 6), 9], 'TTTGTTTCA', 1) #A4c
        #puts "line 247"
        spliceMap << "D1" << "A4c"
        return spliceMap

        elsif closeEnough?(sequence[(idx + 6), 9], 'CCTTAGGCA', 1) #A4a
        #puts "line 253"
        spliceMap << "D1" << "A4a"
        return spliceMap


        elsif closeEnough?(sequence[(idx + 6), 9], 'GCATCTCCT', 1) #A4b
        #puts "line 260"
        spliceMap << "D1" << "A4b"
        return spliceMap

        elsif closeEnough?(sequence[(idx + 6), 9],'GAAGAAGCG', 1) #A5
        #puts "line 259"
        spliceMap << "D1" << "A5a"
        return spliceMap

        elsif closeEnough?(sequence[(idx + 6), 9], 'AAGCGGAGA', 1) #A5b
        #puts "line 273"
        spliceMap << "D1" << "A5b"
        return spliceMap

        elsif closeEnough?(sequence[(idx + 6), 9], 'ACCCACCTC', 1) #A7
        spliceMap << "D1" << "A7"
        return spliceMap

        ########### end of acceptors with muations
        else
        unknownAcceptor = sequence[idx + 6, 10]
        unknownAcceptorIdx = identifyAcceptor(unknownAcceptor)
        if ((unknownAcceptorIdx != nil) and (unknownAcceptor != nil))
            $unknownAcceptors << [unknownAcceptorIdx, unknownAcceptor]
            else
            $unknownAcceptors << ["no index", unknownAcceptor]
        end
        return spliceMap
    end
    return spliceMap
end

#finds where the reverse primer binds - only works for gag reads, looks in the 600 bases downstream of D1
#this function gets called for 'unspliced' forward reads
def gagBindSite(reverseSequence) #find where the reverse primer binds
    #search rcRef, which is the rc of the 600 bases starting at D1
    #this will only be called for "unspliced" forward reads
    #this is the NL4-3 sequence
    #TTTYCCACCCCC is the cDNA primer OR TTTCCCACCCCC / TTTTCCACCCCC
    #RC of the CommonK-mer reverse primer: GGGGGTGGGAAA / GGGGGTGGAAAA
    if reverseSequence[8, 16].include?("TTTCCCACCCCC") || reverseSequence[8,16].include?("TTTTCCACCCCC")
        pidx = reverseSequence.index("CCACCCCC")
        #puts pidx
        testSeq = reverseSequence[(pidx + 8), 12] #what comes right after the primer
        if bidx = $rcRef.index(testSeq)
            #puts bidx
            bidxActual = 600 - (bidx) + 743
            #puts bidxActual
            bindSequence = $rcRef[bidx-12, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $gagBindingTally[bidxActual] += 1
            $gagBindingHash[bidxActual] = bindSequence unless $gagBindingHash[bidxActual]
        #try with the next 12 bases, in case the first 12 had mutations
        elsif bidx = $rcRef.index(reverseSequence[(pidx + 20), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 743 + 12
            #puts bidxActual
            bindSequence = $rcRef[bidx-24, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $gagBindingTally[bidxActual] += 1
            $gagBindingHash[bidxActual] = bindSequence unless $gagBindingHash[bidxActual]
        #try with 24 bases out
        elsif bidx = $rcRef.index(reverseSequence[(pidx + 32), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 743 + 24
            #puts bidxActual
            bindSequence = $rcRef[bidx-36, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $gagBindingTally[bidxActual] += 1
            $gagBindingHash[bidxActual] = bindSequence unless $gagBindingHash[bidxActual]
        end

    elsif closeEnough?(reverseSequence[10, 12], "TTTCCCACCCCC", 2) or closeEnough?(reverseSequence[10, 12], "TTTTCCACCCCC", 2)
        pidx = 10
        testSeq = reverseSequence[(pidx + 12), 12] #what comes right after the primer
        if bidx = $rcRef.index(testSeq)
            #puts bidx
            bidxActual = 600 - (bidx) + 743
            #puts bidxActual
            bindSequence = $rcRef[bidx-12, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $gagBindingTally[bidxActual] += 1
            $gagBindingHash[bidxActual] = bindSequence unless $gagBindingHash[bidxActual]
        #try with the next 12 bases, in case the first 12 had mutations
        elsif bidx = $rcRef.index(reverseSequence[(pidx + 24), 12])
            bidxActual = 600 - (bidx) + 743 + 12
            bindSequence = $rcRef[bidx-24, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $gagBindingTally[bidxActual] += 1
            $gagBindingHash[bidxActual] = bindSequence unless $gagBindingHash[bidxActual]
        #try with 24 bases out
        elsif bidx = $rcRef.index(reverseSequence[(pidx + 36), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 743 + 24
            #puts bidxActual
            bindSequence = $rcRef[bidx-36, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $gagBindingTally[bidxActual] += 1
            $gagBindingHash[bidxActual] = bindSequence unless $gagBindingHash[bidxActual]
        end

    else
    puts reverseSequence[0,80]
    end

end

#finds where the reverse primer binds if it's a spliced read with unexpected cDNA priming, looks in the 600 bases downstream of D4 or A7
#this function gets called for spliced forward reads that have a nil size class ID
#6045 is the first base after D4 in full length indexes
#8369 is the first base after A7 in full length indexes
def splicedBindSite(reverseSequence) #find where the reverse primer binds
    #search $rcComplete, which is the rc of the 600 bases starting at A7
    #and $rcIncomp, which is the rc of the 600 bases starting at D4
    #this will only be called for spliced forward reads without a size class designation
    #this is the NL4-3 sequence
    #TTTYCCACCCCC is the cDNA primer OR TTTCCCACCCCC / TTTTCCACCCCC
    #RC of the CommonK-mer reverse primer: GGGGGTGGGAAA / GGGGGTGGAAAA
    if reverseSequence[8, 16].include?("TTTCCCACCCCC") or reverseSequence[8,16].include?("TTTTCCACCCCC")
        pidx = reverseSequence.index("CCACCCCC")
        #puts pidx
        testSeq = reverseSequence[(pidx + 8), 12] #what comes right after the primer
        #look for for COMPLETELY SPLICED PRIMED area
        if bidx = $rcComplete.index(testSeq) #it matches in the competely primed
            #puts bidx
            bidxActual = 600 - (bidx) + 8369
            #puts bidxActual
            bindSequence = $rcComplete[bidx-12, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $completeBindTally[bidxActual] += 1
            $completeHash[bidxActual] = bindSequence unless $completeHash[bidxActual]
            return "1.8kb"
        #look for the INCOMPLETELY SPLICED PRIMED area
        elsif bidx = $rcIncomp.index(testSeq) #if finds the incompletely primed area
            #puts bidx
            bidxActual = 600 - (bidx) + 6045
            #puts bidxActual
            bindSequence = $rcIncomp[bidx-12, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $incompBindTally[bidxActual] += 1
            $incompHash[bidxActual] = bindSequence unless $incompHash[bidxActual]
            return "4kb"

#        elsif somewhereElse = $ref.index(returnRC(testSeq))
#            puts somewhereElse
#            puts testSeq
#            puts returnRC(testSeq)
#            puts

        #try with the next 12 bases, in case the first 12 had mutations
        #look for the COMPLETELY SPLICED PRIMED AREA
        elsif bidx = $rcComplete.index(reverseSequence[(pidx + 20), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 8369 + 12
            #puts bidxActual
            bindSequence = $rcComplete[bidx-24, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $completeBindTally[bidxActual] += 1
            $completeHash[bidxActual] = bindSequence unless $completeHash[bidxActual]
            return "1.8kb"
        #look for the INCOMPLETELY SPLICED PRIMED AREA
        elsif bidx = $rcIncomp.index(reverseSequence[(pidx + 20), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 6045 + 12
            #puts bidxActual
            bindSequence = $rcIncomp[bidx-24, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $incompBindTally[bidxActual] += 1
            $incompHash[bidxActual] = bindSequence unless $incompHash[bidxActual]
            return "4kb"

        #try with 24 bases out
        #look for the COMPLETELY SPLICED PRIMED AREA
        elsif bidx = $rcComplete.index(reverseSequence[(pidx + 32), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 8369 + 24
            #puts bidxActual
            bindSequence = $rcComplete[bidx-36, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $completeBindTally[bidxActual] += 1
            $completeHash[bidxActual] = bindSequence unless $completeHash[bidxActual]
            return "1.8kb"
        #look for the INCOMPLETELY SPLICED PRIMED AREA
        elsif bidx = $rcIncomp.index(reverseSequence[(pidx + 32), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 6045 + 24
            #puts bidxActual
            bindSequence = $rcIncomp[bidx-36, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $incompBindTally[bidxActual] += 1
            $incompHash[bidxActual] = bindSequence unless $incompHash[bidxActual]
            return "4kb"
        end

    elsif closeEnough?(reverseSequence[10, 12], "TTTCCCACCCCC", 2) or closeEnough?(reverseSequence[10, 12], "TTTTCCACCCCC", 2)
        pidx = 10
        testSeq = reverseSequence[(pidx + 12), 12] #what comes right after the primer
        #look for for COMPLETELY PRIMED area
        if bidx = $rcComplete.index(testSeq) #it matches in the competely primed
            #puts bidx
            bidxActual = 600 - (bidx) + 8369
            #puts bidxActual
            bindSequence = $rcComplete[bidx-12, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $completeBindTally[bidxActual] += 1
            $completeHash[bidxActual] = bindSequence unless $completeHash[bidxActual]
            return "1.8kb"
        #look for the INCOMPLETELY PRIMED area
        elsif bidx = $rcIncomp.index(testSeq) #if finds the incompletely primed area
            #puts bidx
            bidxActual = 600 - (bidx) + 6045
            #puts bidxActual
            bindSequence = $rcIncomp[bidx-12, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $incompBindTally[bidxActual] += 1
            $incompHash[bidxActual] = bindSequence unless $incompHash[bidxActual]
            return "4kb"

        #try with the next 12 bases, in case the first 12 had mutations
        #look for the COMPLETELY PRIMED
        elsif bidx = $rcComplete.index(reverseSequence[(pidx + 20), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 8369 + 12
            #puts bidxActual
            bindSequence = $rcComplete[bidx-24, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $completeBindTally[bidxActual] += 1
            $completeHash[bidxActual] = bindSequence unless $completeHash[bidxActual]
            return "1.8kb"
        #look for the INCOMPLETELY PRIMED
        elsif bidx = $rcIncomp.index(reverseSequence[(pidx + 20), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 6045 + 12
            #puts bidxActual
            bindSequence = $rcIncomp[bidx-24, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $incompBindTally[bidxActual] += 1
            $incompHash[bidxActual] = bindSequence unless $incompHash[bidxActual]
            return "4kb"

        #try with 24 bases out
        #look for the COMPLETELY PRIMED
        elsif bidx = $rcComplete.index(reverseSequence[(pidx + 32), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 8369 + 24
            #puts bidxActual
            bindSequence = $rcComplete[bidx-36, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $completeBindTally[bidxActual] += 1
            $completeHash[bidxActual] = bindSequence unless $completeHash[bidxActual]
            return "1.8kb"
        #look for the INCOMPLETELY PRIMED
        elsif bidx = $rcIncomp.index(reverseSequence[(pidx + 32), 12])
            #puts bidx
            bidxActual = 600 - (bidx) + 6045 + 24
            #puts bidxActual
            bindSequence = $rcIncomp[bidx-36, 12] #this is  where the primer actually bound
            #puts testSeq
            #puts bindSequence
            #puts
            #puts
            $incompBindTally[bidxActual] += 1
            $incompHash[bidxActual] = bindSequence unless $incompHash[bidxActual]
            return "4kb"
        end

    else
    puts reverseSequence[0,80]
    end

end


#has alread found D1 to A1, look here for D2 either making SX2 or not splicing after D2 making vif
def sort_forward_sequence_A1(sequence)#has alread found D1 to A1, look here for D2 either making SX2 or not splicing after D2 making vif
    spliceMap = []
    l = sequence.length
    #look for D2 sequence
    if sequence[33, 10].include?('TCTGGA') # Finds D2 search sequence - using this sequence 9 bases upstream of D2 because it is not as common as GGAAAG.
        #puts "OK D2"
        idx = sequence.index('TCTGGA', 33) #index for pre D2 search string
        #puts idx  # it's 35
        # first look for vif, no splicing at D2 OR D2b
        if closeEnough?(sequence[(idx + 9), 9], 'GTGAAGGGG', 1)  # finds post D2-there is no splice at D2,
            if sequence[(idx + 103), 15].include?('GTGATGATT')#post D2b-doesn't splice at D2b either
                #puts sequence.index('GTGATGATT') #it's 140, location of post D2b
                #it's a vif transcript
                spliceMap << "Vif"
                return spliceMap
                else #close enough for not spliced at D2b
                for d in (idx + 94)..(idx + 104)
                    if closeEnough?(sequence[d, 15], 'GTGATGATTGTGTGG', 2) #NL4-3 D
                        spliceMap << "Vif"
                        return spliceMap
                    end
                end
            end
            # check for splicing from D2 to a known acceptor in this order: A5, A2, A4a, A4b, A3, A5b, A4c
            # SX1 to a downstream acceptor
            elsif ((sequence[(idx + 9), 6] == 'GAAGAA')  || (sequence[(idx + 9), 6] == 'AATCTG') || (sequence[(idx + 9), 6] == 'CCTTAG') || (sequence[(idx + 9), 6] == 'GCATCT') || (sequence[(idx + 9), 6] == 'AATTGG') || (sequence[(idx + 9), 6] == 'AAGCGG') || (sequence[(idx + 9), 6] == 'TTTGTT') || (sequence[(idx + 9), 6] == 'ACAAAA'))
            #finds a cannonical acceptor
            return spliceMap << sort_forward_sequence_D2(sequence[(idx + 9)..l])
            #repeat the above search with closeEnough?
            elsif ((closeEnough?(sequence[(idx + 9), 9], 'GAAGAAGCG', 1))  || (closeEnough?(sequence[(idx + 9), 9], 'AATCTGCTA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'CCTTAGGCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'GCATCTCCT', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AATTGGGTG', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AAGCGGAGA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'TTTGTTTCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'ACAAAAGGC', 1)))
            #finds close enough to a cannonical acceptor
            return spliceMap << sort_forward_sequence_D2(sequence[(idx + 9)..l])
            else
            spliceMap << "D2"
            #puts sequence[(idx + 9), 10]
            return spliceMap # it finds D2 but no acceptor after D2, look next in reverse read
        end

        else  # an unmutated D2 was not found, try closeEnough and repeat all functionality above
        for k in (33..39)
            if closeEnough?(sequence[k,9], 'TCTGGAAAG', 1 )
                idx = k
                if closeEnough?(sequence[(idx + 9), 9], 'GTGAAGGGG', 1)  # there is no splice at D2,
                    if sequence[(idx + 94), 20].include?('AGATGGCAGGTGATG')#doesn't splice at D2b either
                        #it's a vif transcript
                        spliceMap << "Vif"
                        return spliceMap
                        else #close enough for not spliced at D2b
                        for d in (idx + 94)..(idx + 104)
                            if closeEnough?(sequence[d, 15], 'AGATGGCAGGTGATG', 2) #NL4-3 D
                                spliceMap << "Vif"
                                return spliceMap
                            end
                        end
                    end
                    # check for splicing from D2 to a known acceptor in this order: A5, A2, A4a, A4b, A3, A5b, A4c
                    # SX1 to a downstream acceptor
                    elsif ((sequence[(idx + 9), 6] == 'GAAGAA')  || (sequence[(idx + 9), 6] == 'AATCTG') || (sequence[(idx + 9), 6] == 'CCTTAG') || (sequence[(idx + 9), 6] == 'GCATCT') || (sequence[(idx + 9), 6] == 'AATTGG') || (sequence[(idx + 9), 6] == 'AAGCGG') || (sequence[(idx + 9), 6] == 'TTTGTT') || (sequence[(idx + 9), 6] == 'ACAAAA'))
                    #finds a cannonical acceptor
                    return spliceMap << sort_forward_sequence_D2(sequence[(idx + 9)..l])
                    #repeat the above search with closeEnough?
                    elsif ((closeEnough?(sequence[(idx + 9), 9], 'GAAGAAGCG', 1))  || (closeEnough?(sequence[(idx + 9), 9], 'AATCTGCTA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'CCTTAGGCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'GCATCTCCT', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AATTGGGTG', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AAGCGGAGA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'TTTGTTTCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'ACAAAAGGC', 1)))
                    #close enough to a cannonical acceptor
                    #puts "D2 close enough" #working
                    return spliceMap << sort_forward_sequence_D2(sequence[(idx + 9)..l])
                    else
                    spliceMap << "D2"
                    #puts sequence[(idx + 9), 10]
                    return spliceMap # it finds D2 but no acceptor after D2, look next in reverse read
                end
            end
        end
    end
    #doesn't find D2 search string and it isn't vif
    #look for splicing from D2b
    #puts "look for D2b"  #many reads make it to here
    if sequence[132, 10].include?('TGGCAG')  #pre D2b sequence, it's at 134, we already know the post D2b sequence is not present
        d2bIdx = sequence.index('TGGCAG', 132)
        # check for splicing from D2b to a known acceptor in this order: A5, A2, A4a, A4b, A3, A5b, A4c, no Splice
        # SX1 to a downstream acceptor
        if ((sequence[(d2bIdx + 6), 6] == 'GAAGAA')  || (sequence[(d2bIdx + 6), 6] == 'AATCTG') || (sequence[(d2bIdx + 6), 6] == 'CCTTAG') || (sequence[(d2bIdx + 6), 6] == 'GCATCT') || (sequence[(d2bIdx + 6), 6] == 'AATTGG') || (sequence[(d2bIdx + 6), 6] == 'AAGCGG') || (sequence[(d2bIdx + 6), 6] == 'TTTGTT') || (sequence[(d2bIdx + 6), 6] == 'ACAAAA') || (sequence[(d2bIdx + 6), 6] == 'GTGATG'))
            #finds a cannonical acceptor
            return spliceMap << sort_forward_sequence_D2b(sequence[(d2bIdx + 6)..l])
            #repeat the above search with closeEnough?
            elsif ((closeEnough?(sequence[(d2bIdx + 6), 9], 'GAAGAAGCG', 1))  || (closeEnough?(sequence[(d2bIdx + 6), 9], 'AATCTGCTA', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'CCTTAGGCA', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'GCATCTCCT', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'AATTGGGTG', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'AAGCGGAGA', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'TTTGTTTCA', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'ACAAAAGGC', 1)) || (closeEnough?(sequence[(d2bIdx + 6), 9], 'GTGATGATT', 1)))
            #finds close enough to a cannonical acceptor
            return spliceMap << sort_forward_sequence_D2b(sequence[(d2bIdx + 6)..l])
            else
            spliceMap << "D2b"
            #puts sequence[(d2bIdx + 6), 10]
            return spliceMap # it finds D2b but no acceptor after D2b
        end

    end

    return spliceMap
end




def sort_forward_sequence_A2(sequence)#
    spliceMap = []
    l = sequence.length
    #look for D3 sequence #started at [56, 10], [62, 10]
    if sequence[57, 10].include?('CATAAC')# finds this D3 search sequence 9 bases upstream of the D3 cut
        #puts "OK D3"
        idx = sequence.index('CATAAC', 57)
        #first look for vpr, no splicing at D3
        if closeEnough?(sequence[(idx + 9), 9], 'GTAGGATCT', 1) #there is no splice at D3, it's a vpr transcript
            spliceMap << "Vpr"
            return spliceMap
            # check for splicing from D3 to a known acceptor in this order: A5, A4a, A4b, A3, A5b, A4c
            #SX2 to a downstream acceptor
            elsif ((sequence[(idx + 9), 6] == 'GAAGAA')  || (sequence[(idx + 9), 6] == 'CCTTAG') || (sequence[(idx + 9), 6] == 'GCATCT') || (sequence[(idx + 9), 6] == 'AATTGG') || (sequence[(idx + 9), 6] == 'AAGCGG') || (sequence[(idx + 9), 6] == 'TTTGTT') || (sequence[(idx + 9), 6] == 'ACAAAA'))
            #finds a cannonical acceptor
            return spliceMap << sort_forward_sequence_D3(sequence[(idx + 9)..l])
            elsif ((closeEnough?(sequence[(idx + 9), 9], 'GAAGAAGCG', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'CCTTAGGCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'GCATCTCCT', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AATTGGGTG', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AAGCGGAGA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'TTTGTTTCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'ACAAAAGGC', 1)))
            #close enough to a cannonical splice acceptor
            return spliceMap << sort_forward_sequence_D3(sequence[(idx + 9)..l])
            else #it finds D3 but no acceptor after D3, look next in reverse read
            spliceMap << "D3"
            #puts sequence[(idx + 9), 6]
            return spliceMap
        end
        else
        for k in 57..63
            #doesn't find the unmutated D3 sequence, looks for one closeEnough?()
            if closeEnough?(sequence[k, 9], 'CATAACAAG', 1)
                idx = k
                #puts "line 411"
                #first look for vpr, no splicing at D3
                if closeEnough?(sequence[(idx + 9), 9], 'GTAGGATCT', 1) #there is no splice at D3, it's a vpr transcript
                    spliceMap << "Vpr"
                    return spliceMap
                    # check for splicing from D3 to a known acceptor in this order: A5, A4a, A4b, A3, A5b, A4c
                    #SX2 to a downstream acceptor
                    elsif ((sequence[(idx + 9), 6] == 'GAAGAA')  || (sequence[(idx + 9), 6] == 'CCTTAG') || (sequence[(idx + 9), 6] == 'GCATCT') || (sequence[(idx + 9), 6] == 'AATTGG') || (sequence[(idx + 9), 6] == 'AAGCGG') || (sequence[(idx + 9), 6] == 'TTTGTT') || (sequence[(idx + 9), 6] == 'ACAAAA'))
                    #finds a cannonical acceptor
                    return spliceMap << sort_forward_sequence_D3(sequence[(idx + 9)..l])
                    elsif ((closeEnough?(sequence[(idx + 9), 9], 'GAAGAAGCG', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'CCTTAGGCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'GCATCTCCT', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AATTGGGTG', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'AAGCGGAGA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'TTTGTTTCA', 1)) || (closeEnough?(sequence[(idx + 9), 9], 'ACAAAAGGC', 1)))
                    #finds a close enough cannonical acceptor
                    return spliceMap << sort_forward_sequence_D3(sequence[(idx + 9)..l])
                    else #it finds D3 but no acceptor after D3, look next in reverse read
                    spliceMap << "D3"
                    #puts sequence[(idx + 9), 6]
                    return spliceMap
                end
            end
        end
    end
    #puts "no D3 search string"
    #puts sequence[57, 10]
    #doesnt find D3 search string and isn't vpr, look next in reverse read
    return spliceMap
end




def sort_forward_sequence_D2(sequence)
    spliceMap = []
    l = sequence.length

    if (sequence[ 0, 6].eql?('AATCTG'))  #A2 NL4-3 A2 sequence
        spliceMap << "D2" << "A2"
        return spliceMap << sort_forward_sequence_A2(sequence[6..l])

        elsif (sequence[ 0, 6].eql?('AATTGG'))  #A3
        spliceMap << "D2" << "A3"
        return spliceMap

        elsif sequence[ 0, 6].eql?('TGTTGC')  #A4d
        spliceMap << "D2" << "A4d"
        return spliceMap

        elsif sequence[ 0, 6].eql?('TTTGTT')  #A4c
        spliceMap << "D2" << "A4c"
        return spliceMap

        elsif sequence[ 0, 6].eql?('CCTTAG') #A4a
        spliceMap << "D2" << "A4a"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GCATCT')#A4b
        spliceMap << "D2" << "A4b"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GAAGAA') #A5
        spliceMap << "D2" << "A5a"
        return spliceMap

        elsif sequence[ 0, 6].eql?('AAGCGG') #A5b
        spliceMap << "D2" << "A5b"
        return spliceMap

        elsif sequence[ 0, 6].eql?('ACCCAC') #A7
        spliceMap << "D2" << "A7"
        return spliceMap

        ######### cannonical acceptors with mutations - use closeEnough?()

        elsif closeEnough?(sequence[0, 9], 'AATCTGCTA', 1) #A2
        spliceMap << "D2" << "A2"
        return spliceMap << sort_forward_sequence_A2(sequence[6..l])

        elsif closeEnough?(sequence[0, 9], 'AATTGGGTG', 1)  #A3
        spliceMap << "D2" << "A3"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'TGTTGCTTT', 1) #A4d
        spliceMap << "D2" << "A4d"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'TTTGTTTCA', 1) #A4c
        spliceMap << "D2" << "A4c"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'CCTTAGGCA', 1) #A4a
        spliceMap << "D2" << "A4a"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'GCATCTCCT', 1) #A4b
        spliceMap << "D2" << "A4b"
        return spliceMap

        elsif closeEnough?(sequence[0, 9],'GAAGAAGCG', 1) #A5
        spliceMap << "D2" << "A5a"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'AAGCGGAGA', 1) #A5b
        spliceMap << "D2" << "A5b"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'ACCCACCTC', 1) #A7
        spliceMap << "D2" << "A7"
        return spliceMap

        ########### end of acceptors with muations

        else
        unknownAcceptor = sequence[0, 10]
        unknownAcceptorIdx = identifyAcceptor(unknownAcceptor)
        if ((unknownAcceptorIdx != nil) and (unknownAcceptor != nil))
            $unknownAcceptors << [unknownAcceptorIdx, unknownAcceptor]
            else
            $unknownAcceptors << ["no index", unknownAcceptor]
        end
        return spliceMap
    end
    return spliceMap
end

def sort_forward_sequence_D2b(sequence)
    spliceMap = []
    l = sequence.length

    if (sequence[ 0, 6].eql?('AATCTG'))  #A2 NL4-3 A2 sequence
        spliceMap << "D2b" << "A2"
        return spliceMap << sort_forward_sequence_A2(sequence[6..l])

        elsif (sequence[ 0, 6].eql?('AATTGG'))  #A3
        spliceMap << "D2b" << "A3"
        return spliceMap

        elsif sequence[ 0, 6].eql?('TGTTGC')  #A4d
        spliceMap << "D2b" << "A4d"
        return spliceMap

        elsif sequence[ 0, 6].eql?('TTTGTT')  #A4c
        spliceMap << "D2b" << "A4c"
        return spliceMap

        elsif sequence[ 0, 6].eql?('CCTTAG') #A4a
        spliceMap << "D2b" << "A4a"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GCATCT')#A4b
        spliceMap << "D2b" << "A4b"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GAAGAA') #A5
        spliceMap << "D2b" << "A5a"
        return spliceMap

        elsif sequence[ 0, 6].eql?('AAGCGG') #A5b
        spliceMap << "D2b" << "A5b"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GTGATG') #Not spliced at D2b
        spliceMap << "D2b" << "Vpr"
        return spliceMap

        ######### cannonical acceptors with mutations - use closeEnough?()

        elsif closeEnough?(sequence[0, 9], 'AATCTGCTA', 1) #A2
        spliceMap << "D2b" << "A2"
        return spliceMap << sort_forward_sequence_A2(sequence[6..l])

        elsif closeEnough?(sequence[0, 9], 'AATTGGGTG', 1)  #A3
        spliceMap << "D2b" << "A3"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'TGTTGCTTT', 1) #A4d
        spliceMap << "D2b" << "A4d"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'TTTGTTTCA', 1) #A4c
        spliceMap << "D2b" << "A4c"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'CCTTAGGCA', 1) #A4a
        spliceMap << "D2b" << "A4a"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'GCATCTCCT', 1) #A4b
        spliceMap << "D2b" << "A4b"
        return spliceMap

        elsif closeEnough?(sequence[0, 9],'GAAGAAGCG', 1) #A5
        spliceMap << "D2b" << "A5a"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'AAGCGGAGA', 1) #A5b
        spliceMap << "D2b" << "A5b"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'GTGATGATT', 1) #not spliced at D2b
        spliceMap << "D2b" << "Vpr"
        return spliceMap

        ########### end of acceptors with muations

        else
        unknownAcceptor = sequence[0, 10]
        unknownAcceptorIdx = identifyAcceptor(unknownAcceptor)
        if ((unknownAcceptorIdx != nil) and (unknownAcceptor != nil))
            $unknownAcceptors << [unknownAcceptorIdx, unknownAcceptor]
            else
            $unknownAcceptors << ["no index", unknownAcceptor]
        end
        return spliceMap
    end
    return spliceMap
end





def sort_forward_sequence_D3(sequence)
    spliceMap = []
    l = sequence.length

    if  sequence[ 0, 6].eql?('AATTGG')  #A3
        spliceMap << "D3" << "A3"
        return spliceMap

        elsif sequence[ 0, 6].eql?('TGTTGC')  #A4d
        spliceMap << "D3" << "A4d"
        return spliceMap

        elsif sequence[ 0, 6].eql?('TTTGTT')  #A4c
        spliceMap << "D3" << "A4c"
        return spliceMap

        elsif sequence[ 0, 6].eql?('CCTTAG') #A4a
        spliceMap << "D3" << "A4a"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GCATCT')#A4b
        spliceMap << "D3" << "A4b"
        return spliceMap

        elsif sequence[ 0, 6].eql?('GAAGAA') #A5
        spliceMap << "D3" << "A5a"
        return spliceMap

        elsif sequence[ 0, 6].eql?('AAGCGG') #A5b
        spliceMap << "D3" << "A5b"
        return spliceMap

        elsif sequence[ 0, 6].eql?('ACCCAC') #A7
        spliceMap << "D3" << "7"
        return spliceMap

        ### use closeEnough? for mutated accceptors
        elsif closeEnough?(sequence[0, 9], 'AATTGGGTG', 1)  #A3
        spliceMap << "D3" << "A3"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'TGTTGCTTT', 1) #A4d
        spliceMap << "D3" << "A4d"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'TTTGTTTCA', 1) #A4c
        spliceMap << "D3" << "A4c"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'CCTTAGGCA', 1) #A4a
        spliceMap << "D3" << "A4a"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'GCATCTCCT', 1) #A4b
        spliceMap << "D3" << "A4b"
        return spliceMap

        elsif closeEnough?(sequence[0, 9],'GAAGAAGCG', 1) #A5
        spliceMap << "D3" << "A5a"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'AAGCGGAGA', 1) #A5b
        spliceMap << "D3" << "A5b"
        return spliceMap

        elsif closeEnough?(sequence[0, 9], 'ACCCACCTC', 1) #A7
        spliceMap << "D3" << "A7"
        return spliceMap

        ########### end of acceptors with muations

        else
        unknownAcceptor = sequence[0, 10]
        unknownAcceptorIdx = identifyAcceptor(unknownAcceptor)
        if ((unknownAcceptorIdx != nil) and (unknownAcceptor != nil))
            $unknownAcceptors << [unknownAcceptorIdx, unknownAcceptor]
            else
            $unknownAcceptors << ["no index", unknownAcceptor]
        end
        return spliceMap
    end
    return spliceMap
end





#checks if forward primer has correctly primed, returns true of false
def forwardCorrectlyPrimed(sequence)
    if sequence[4,8] = "TGCTGAAG" or closeEnough?(sequence[4, 15], "TGCTGAAGCGCGCAC", 3)  #finds forward primer sequence in good quality area, or good enough.
        #puts "forwardPrimerFound"
        if ((sequence[25, 8] == "AGGCGAGG") or (sequence[24,10].include?("AGGCGAGG")) or closeEnough?(sequence[25,15], "AGGCGAGGGGCGGCG", 3))  #skips poor quality reads and finds correct priming site, with a one base leeway.
            return true
            #puts "correctlyPrimed"
        else
            #puts "incorrectlyPrimed"
            return false
        end
    end
    #forward primer not found
    return false
end

#catagorizes reverse primer binding that has primed at expected 4KB or 1.8KB sites, returns either "4kb", "1.8kb", or nil
def reverseFind(rsequence) #rsequence is 16 bases (@773)
    #4kb post primer sequence: ATCTCCACAAGTGCTGATACTT
    if rsequence[0, 6] == "ATCTCC" #did it prime correctly in the 4 kb
        type = "4kb"
        #puts type
        return type
    #1.8KB post primer sequence: TGCGTCCCAGAAGTTCCACAAT
    elsif rsequence[0, 6] == "TGCGTC" #did it prime correctly in the 1.8 kb
        type = "1.8kb"
        #puts type
        return type
    #internal Gag post primer sequence: GCTTAATACCGACGCTCTCGCA
#    elsif rsequence[0, 6] == "GCTTAA"
#        type = "Gag"
#        return type
#    elsif rsequence[0, 6] == "TGGCCT"
#        type = "Gag"
#        return type
#    elsif rsequence[0, 6] == "TCTCTC"
#        type = "Gag"
#        return type
#    elsif rsequence[0, 6] == "GCTAGT"
#        type = "Gag"
#        return type

    elsif closeEnough?(rsequence, "ATCTCCACAAGTGCTG", 3)
        type = "4kb"
        return type
    elsif closeEnough?(rsequence, "TGCGTCCCAGAAGTTC", 3)
        type = "1.8kb"
        return type
#    elsif closeEnough?(rsequence, "GCTTAATACCGACGCT", 3)
#        type = "Gag"
#        return type
#    elsif closeEnough?(rsequence, "TGGCCTTAACCGAATT", 3)
#        type = "Gag"
#        return type
#    elsif closeEnough?(rsequence, "TCTCTCCTTCTAGCCT", 3)
#        type = "Gag"
#        return type
#    elsif closeEnough?(rsequence, "GCTAGTCAAAATTTTT", 3)
#        type = "Gag"
#        return type
    else type = nil
        #puts rsequence
        return type
    end
end







#takes FASTQ files

forwardFile, reverseFile = ARGV

forward = File.open(forwardFile, 'r')
reverse = File.open(reverseFile, 'r')

name = ""
sequence = ""
sequenceHash = {}
countIDHash = Hash.new(0)

line_count = 1


$unknownAcceptors = []
$gagBindingTally = Hash.new(0)
$gagBindingHash = {}
$completeBindTally = Hash.new(0)
$completeHash = {}
$incompBindTally = Hash.new(0)
$incompHash = {}
completeSpliceIncompletePrimer = 0
completeSpliceCompletePrimer = 0
incompleteSpliceIncompletePrimer = 0
incompleteSpliceCompletePrimer = 0


while (line = forward.gets and line.strip != nil) && (rline = reverse.gets and rline.strip != nil) do
#    if line_count > 21
#        break
#    end
    if line_count % 4 == 1
        pID = nil
        sequence = nil
        rsequence = nil
        nameF = line.split[0]
        nameR = rline.split[0]
        if nameF.eql?(nameR)
            name = nameF
            else
            puts "File lines not correlated!!"
            break
        end

    elsif line_count % 4 == 2
        sequence = line
        rsequence = rline
        notPrimerDimer = forwardCorrectlyPrimed(sequence)
    elsif line_count % 4 == 0
        reverseQualityGood = true
        rsequence[0,10].each_codepoint do |q|
            if q <= 53   # >=53 to ASCII 5, which is a 1% chance of miscall, or >= #56, ASCII 8, .5% miscall
                reverseQualityGood = false
                break
            end
        end

        if (notPrimerDimer and reverseQualityGood) #if it's not a primer dimer and the PID passes quality check
            pID = rsequence[0,10]
            fseq_array = sort_forward_sequence(sequence).flatten()

            matchSequence = rsequence[22, 16] #sequence after reverse primer
            #reverse primer variations: TTTCCCACCCCC / TTTTCCACCCCC
            #the first T is to distinguish it from an RR prime
            sizeClass = reverseFind(matchSequence)
            #this block is to quantify how specific the degenerate primers are for the 1.8 or 4 kb intended sequences
            if rsequence[10,12] == "TTTCCCACCCCC" #completely spliced primer
                if sizeClass == "1.8kb"
                    completeSpliceCompletePrimer += 1
                elsif sizeClass == "4kb"
                    incompleteSpliceCompletePrimer += 1
                end
            elsif rsequence[10,12] == "TTTTCCACCCCC" #incompletely spliced primer
                if sizeClass == "1.8kb"
                    completeSpliceIncompletePrimer += 1
                elsif sizeClass == "4kb"
                    incompleteSpliceIncompletePrimer += 1
                end
            end

            if sizeClass != nil and fseq_array != []
                fseq_array << sizeClass
                sequenceHash[pID] = fseq_array unless sequenceHash[pID]
                countIDHash[pID] += 1
            elsif sizeClass == nil and fseq_array == ["unspliced"]
                sizeClass = "Gag"
                gagBindSite(rsequence)
                fseq_array << sizeClass
                sequenceHash[pID] = fseq_array unless sequenceHash[pID]
                countIDHash[pID] += 1
            #the fseq_array exists but there's no reverse priming info - a reverse misprime
            elsif sizeClass == nil and fseq_array != [] #it isn't 'unspliced' but it was short enough to sequence, so it's likely a misprimed cDNA primer.  If it primed near the 4kb or 1.8kb expected priming sites, it can be ID'd.
                sizeClass = splicedBindSite(rsequence)
                #if sizeClass == "4kb"
                    #puts(sizeClass + " line1170")
                end
                if sizeClass != nil
                    fseq_array << sizeClass
                    sequenceHash[pID] = fseq_array unless sequenceHash[pID]
                    countIDHash[pID] += 1
                end
            end
        end
    end
    line_count += 1
end
#print sequenceHash



sortHash = Hash.new(0)
oddballs = []


sequenceHash.each do |id, spliceMap|


    #    if  (spliceMap.class() == Fixnum or (spliceMap == "D1"))
    #        puts "D1"
    #        next
    #    end
    if spliceMap.join(" ").eql?("unspliced Gag")
        sortHash["unspliced"] += 1
        sortHash["Good Reads"] += 1


    elsif spliceMap.join(" ").eql?("D1 A5a 1.8kb")
        sortHash["Nef 2"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5a Direct"] += 1
        sortHash["A5a Total"] += 1
        sortHash["A5 Direct Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5a Direct 1.8kb"] += 1
        sortHash["A5a Total 1.8kb"] += 1
        sortHash["A5 Direct Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A4a 1.8kb")
        sortHash["Rev 2"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4a Direct"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4a Direct 1.8kb"] += 1
        sortHash["A4a Total 1.8kb"] += 1
        sortHash["A4 Direct Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A1 D2 A5a 1.8kb")
        sortHash["Nef 3"] += 1
        sortHash["Nef Total"] += 1
        sortHash["SX1 to A5a"] += 1
        sortHash["A5a Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A5a Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 to A5a 1.8kb"] += 1
        sortHash["A5a Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["A5a Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A2 D3 A5a 1.8kb")
        sortHash["Nef 4"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5a Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5a"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A5a"] += 1
        sortHash["A5a Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A2 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5a Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A5a 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A5a 1.8kb"] += 1
        sortHash["A5a Indirect 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A4b 1.8kb")
        sortHash["Rev 1"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4b Direct"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4b Direct 1.8kb"] += 1
        sortHash["A4b Total 1.8kb"] += 1
        sortHash["A4 Direct Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A5a 1.8kb")
        sortHash["Nef 5"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5a Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5a"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A5a"] += 1
        sortHash["A5a Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["Nef 5 1.8kb"] += 1
        sortHash["Nef Total 1.8kb"] += 1
        sortHash["A5a Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A5a 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX1 to SX2 to A5a 1.8kb"] += 1
        sortHash["A5a Indirect 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4a 1.8kb")
        sortHash["Rev 8"] += 1
        sortHash["Rev Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4a"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4a"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4a Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A2 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A4a 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A4a 1.8kb"] += 1
        sortHash["A4a Total 1.8kb"] += 1
        sortHash["A4a Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4b 1.8kb")
        sortHash["Rev 7"] += 1
        sortHash["Rev Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4b"] += 1
        sortHash["SX2 to A4b"] += 1
        sortHash["A4b Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A2 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["A4b Total 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A4b 1.8kb"] += 1
        sortHash["SX2 to A4b 1.8kb"] += 1
        sortHash["A4b Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4a 1.8kb")
        sortHash["Rev 11"] += 1
        sortHash["Rev Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A4a"] += 1
        sortHash["SX2 to A4a"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4a Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX1 to SX2 to A4a 1.8kb"] += 1
        sortHash["SX2 to A4a 1.8kb"] += 1
        sortHash["A4a Total 1.8kb"] += 1
        sortHash["A4a Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4b 1.8kb")
        sortHash["Rev 10"] += 1
        sortHash["Rev Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A4b"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 to A4b"] += 1
        sortHash["A4b Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX1 to SX2 to A4b 1.8kb"] += 1
        sortHash["A4b Total 1.8kb"] += 1
        sortHash["SX2 to A4b 1.8kb"] += 1
        sortHash["A4b Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4a 1.8kb")
        sortHash["Rev 5"] += 1
        sortHash["Rev Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4a Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["SX1 to A4a"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["A4a Total 1.8kb"] += 1
        sortHash["A4a Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["SX1 to A4a 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1

    elsif spliceMap.join(" ").eql?( "D1 A2 Vpr 1.8kb")
        sortHash["Vpr 1"] += 1
        sortHash["Vpr Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Final"] += 1
        sortHash["A2 Final 1.8kb"] += 1
        sortHash["A2 Direct and Final"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Direct and Final 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A4c 1.8kb")
        sortHash["Rev 3"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4c Direct"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 1.8kb"] += 1
        sortHash["A4c Direct 1.8kb"] += 1
        sortHash["A4 Direct Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 Vif 1.8kb")
        sortHash["Vif 1"] += 1
        sortHash["Vif Total"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A1 Final"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["A1 Final 1.8kb"] += 1
        sortHash["1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 Vpr 1.8kb")
        sortHash["Vpr 2"] += 1
        sortHash["Vpr Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A2"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Final"] += 1
        sortHash["A2 Final 1.8kb"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A2 Indirect and Final"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["SX1 to A2 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A2 Indirect and Final 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A3 1.8kb")
        sortHash["Tat 2"] += 1
        sortHash["Tat Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A3"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Indirect"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["SX1 to A3 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["A3 Total 1.8kb"] += 1
        sortHash["A3 Indirect 1.8kb"] += 1
        sortHash["Tat Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4b 1.8kb")
        sortHash["Rev 4"] += 1
        sortHash["Rev Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A4b"] += 1
        sortHash["A4b Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["A4b Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["SX1 to A4b 1.8kb"] += 1
        sortHash["A4b Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4c 1.8kb")
        sortHash["Rev 6"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A4c"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A4c Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 to A4c 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["A4c Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1





    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4c 1.8kb")
        sortHash["Rev 9"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4c"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4c"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A4c Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A4c 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A4c 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["A4c Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A3 1.8kb")
        sortHash["Tat 1"] += 1
        sortHash["Tat Total"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A3 Total 1.8kb"] += 1
        sortHash["A3 Direct 1.8kb"] += 1
        sortHash["Tat Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4c 1.8kb")
        sortHash["Rev 12"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX2 to A4c"] += 1
        sortHash["SX1 to SX2 to A4c"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A4c Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX2 to A4c 1.8kb"] += 1
        sortHash["SX1 to SX2 to A4c 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["A4c Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1




    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A3 1.8kb")
        sortHash["Tat 4"] += 1
        sortHash["Tat Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX2 to A3"] += 1
        sortHash["SX1 to SX2 to A3"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Indirect"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX2 to A3 1.8kb"] += 1
        sortHash["SX1 to SX2 to A3 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["A3 Total 1.8kb"] += 1
        sortHash["A3 Indirect 1.8kb"] += 1
        sortHash["Tat Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A2 D3 A3 1.8kb")
        sortHash["Tat 3"] += 1
        sortHash["Tat Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A3"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A3"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Indirect"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A3 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A3 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["A3 Total 1.8kb"] += 1
        sortHash["A3 Indirect 1.8kb"] += 1
        sortHash["Tat Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A5b 1.8kb")
        sortHash["Nef 6"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["A5b Direct"] += 1
        sortHash["A5 Direct Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 1.8kb"] += 1
        sortHash["A5b Direct 1.8kb"] += 1
        sortHash["A5 Direct Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A5b 1.8kb")
        sortHash["Nef 7"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A5b"] += 1
        sortHash["A5b Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["SX1 to A5b 1.8kb"] += 1
        sortHash["A5b Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A2 D3 A5b 1.8kb")
        sortHash["Nef 8"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5b"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A5b"] += 1
        sortHash["A5b Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A5b 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A5b 1.8kb"] += 1
        sortHash["A5b Indirect 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A5b 1.8kb")
        sortHash["Nef 9"] += 1
        sortHash["Nef Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5b"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A5b"] += 1
        sortHash["A5b Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 1.8kb"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A5b 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX1 to SX2 to A5b 1.8kb"] += 1
        sortHash["A5b Indirect 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A4d 1.8kb")
        sortHash["Rev d"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4d Direct"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 1.8kb"] += 1
        sortHash["A4d Direct 1.8kb"] += 1
        sortHash["A4 Direct Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4d 1.8kb")
        sortHash["Rev d1"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A4d"] += 1
        sortHash["A4d Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX1 without SX2 1.8kb"] += 1
        sortHash["SX1 to A4d 1.8kb"] += 1
        sortHash["A4d Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4d 1.8kb")
        sortHash["Rev d2"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4d"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4d"] += 1
        sortHash["A4d Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A4d 1.8kb"] += 1
        sortHash["SX2 without SX1 1.8kb"] += 1
        sortHash["SX2 without SX1 to A4d 1.8kb"] += 1
        sortHash["A4d Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Direct 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4d 1.8kb")
        sortHash["Rev d12"] += 1
        sortHash["Rev Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4d"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A4d"] += 1
        sortHash["A4d Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 1.8kb"] += 1
        sortHash["SX1 Total 1.8kb"] += 1
        sortHash["SX2 Total 1.8kb"] += 1
        sortHash["SX2 to A4d 1.8kb"] += 1
        sortHash["SX1 to SX2 1.8kb"] += 1
        sortHash["SX1 to SX2 to A4d 1.8kb"] += 1
        sortHash["A4d Indirect 1.8kb"] += 1
        sortHash["A4 Indirect Total 1.8kb"] += 1
        sortHash["A2 Total 1.8kb"] += 1
        sortHash["A2 Indirect 1.8kb"] += 1
        sortHash["A1 Total 1.8kb"] += 1
        sortHash["1.8kb"] += 1
        sortHash["A4 Total 1.8kb"] += 1



        ######D2b Cryptics



    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 Vpr 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 Vpr"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 Vpr 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A3 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A3"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A3 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4a 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A4a 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4b 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A4b 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4c 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4c"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A4c 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4d 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4d"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A4d 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A5a 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A5a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A5a 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A5b 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A5b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A5b 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A3 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A3"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A3 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4a 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4a 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4b 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4b 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4c 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4c"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4c 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4c 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4c"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4c 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A5a 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A5a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A5a 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A5b 1.8kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A5b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 1.8kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A5b 1.8kb"] += 1
        sortHash["1.8kb Cryptic"] += 1


    #for splices to A7
    elsif spliceMap.join(" ").eql?("D1 A7 1.8kb")
        sortHash["Nef 1"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A7 Total"] += 1
        sortHash["A7 Direct"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A7 1.8kb")
        sortHash["Nef 1.1"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A7 Total"] += 1
        sortHash["A7 Indirect"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A7"] += 1
        sortHash["SX1 without SX2"] += 1

    elsif spliceMap.join(" ").eql?("D1 A2 D3 A7 1.8kb")
        sortHash["Nef 1.2"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A7 Total"] += 1
        sortHash["A7 Indirect"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A7"] += 1
        sortHash["SX2 without SX1"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A7 1.8kb")
        sortHash["Nef 1.12"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A7 Total"] += 1
        sortHash["A7 Indirect"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A7"] += 1









#4KB transcripts

    elsif spliceMap.join(" ").eql?("D1 A5a 4kb")
        sortHash["Env 1"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5a Direct"] += 1
        sortHash["A5a Total"] += 1
        sortHash["A5 Direct Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5a Direct 4kb"] += 1
        sortHash["A5a Total 4kb"] += 1
        sortHash["A5 Direct Total 4kb"] += 1
        sortHash["4kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A2 D3 A5a 4kb")
        sortHash["Env 8"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5a Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5a"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A5a"] += 1
        sortHash["A5a Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A2 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5a Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A5a 4kb"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 without SX1 to A5a 4kb"] += 1
        sortHash["A5a Indirect 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A4a 4kb")
        sortHash["Env 3"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4a Direct"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4a Direct 4kb"] += 1
        sortHash["A4a Total 4kb"] += 1
        sortHash["A4 Direct Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A4b 4kb")
        sortHash["Env 2"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4b Direct"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4b Direct 4kb"] += 1
        sortHash["A4b Total 4kb"] += 1
        sortHash["A4 Direct Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A5a 4kb")
        sortHash["Env 5"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5a Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A5a"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A5a Indirect"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5a Total 4kb"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 to A5a 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["A5a Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1




    elsif spliceMap.join(" ").eql?("D1 A1 Vif 4kb")
        sortHash["Vif 2"] += 1
        sortHash["Vif Total"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A1 Final"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["A1 Final 4kb"] += 1
        sortHash["4kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A2 Vpr 4kb")
        sortHash["Vpr 3"] += 1
        sortHash["Vpr Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Final"] += 1
        sortHash["A2 Final 4kb"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A2 Direct and Final"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["A2 Direct and Final 4kb"] += 1
        sortHash["4kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4b 4kb")
        sortHash["Env 10"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 without SX1 to A4b"] += 1
        sortHash["SX2 to A4b"] += 1
        sortHash["A4b Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 without SX1 to A4b 4kb"] += 1
        sortHash["SX2 to A4b 4kb"] += 1
        sortHash["A4b Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A4b Total 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A3 4kb")
        sortHash["Tat 5"] += 1
        sortHash["Tat Total"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A3 Total 4kb"] += 1
        sortHash["A3 Direct 4kb"] += 1
        sortHash["Tat Total 4kb"] += 1
        sortHash["4kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A4c 4kb")
        sortHash["Env 4"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4c Direct"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 4kb"] += 1
        sortHash["A4c Direct 4kb"] += 1
        sortHash["A4 Direct Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1




    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 Vpr 4kb")
        sortHash["Vpr 4"] += 1
        sortHash["Vpr Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A2"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Final"] += 1
        sortHash["A2 Final 4kb"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A2 Indirect and Final"] += 1
        sortHash["A1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 to A2 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A2 Indirect and Final 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["4kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4c 4kb")
        sortHash["Env 16"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX2 to A4c"] += 1
        sortHash["SX1 to SX2 to A4c"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A4c Indirect"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX2 to A4c 4kb"] += 1
        sortHash["SX1 to SX2 to A4c 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["A4c Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A4c Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A5a 4kb")
        sortHash["Env 13"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5a"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A5a"] += 1
        sortHash["A5a Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["A5a Indirect"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A5a 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX1 to SX2 to A5a 4kb"] += 1
        sortHash["A5a Total 4kb"] += 1
        sortHash["A5a Indirect 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A1 D2 A3 4kb")
        sortHash["Tat 6"] += 1
        sortHash["Tat Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A3"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Indirect"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 to A3 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["A3 Total 4kb"] += 1
        sortHash["A3 Indirect 4kb"] += 1
        sortHash["Tat Total 4kb"] += 1
        sortHash["4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4a 4kb")
        sortHash["Env 7"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4a Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["SX1 to A4a"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["A4a Total 4kb"] += 1
        sortHash["A4a Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["SX1 to A4a 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4b 4kb")
        sortHash["Env 6"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A4b"] += 1
        sortHash["A4b Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["A4b Total 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["SX1 to A4b 4kb"] += 1
        sortHash["A4b Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A2 D3 A3 4kb")
        sortHash["Tat 7"] += 1
        sortHash["Tat Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A3"] += 1
        sortHash["SX2 to A3"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Indirect"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 without SX1 to A3 4kb"] += 1
        sortHash["SX2 to A3 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["A3 Total 4kb"] += 1
        sortHash["A3 Indirect 4kb"] += 1
        sortHash["Tat Total 4kb"] += 1
        sortHash["4kb"] += 1

    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4a 4kb")
        sortHash["Env 11"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4a"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4a"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4a Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A4a 4kb"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 without SX1 to A4a 4kb"] += 1
        sortHash["A4a Total 4kb"] += 1
        sortHash["A4a Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A3 4kb")
        sortHash["Tat 8"] += 1
        sortHash["Tat Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX2 to A3"] += 1
        sortHash["SX1 to SX2 to A3"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A3 Total"] += 1
        sortHash["A3 Indirect"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX2 to A3 4kb"] += 1
        sortHash["SX1 to SX2 to A3 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["A3 Total 4kb"] += 1
        sortHash["A3 Indirect 4kb"] += 1
        sortHash["Tat Total 4kb"] += 1
        sortHash["4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4b 4kb")
        sortHash["Env 14"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A4b"] += 1
        sortHash["A4b Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 to A4b"] += 1
        sortHash["A4b Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX1 to SX2 to A4b 4kb"] += 1
        sortHash["A4b Total 4kb"] += 1
        sortHash["SX2 to A4b 4kb"] += 1
        sortHash["A4b Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4c 4kb")
        sortHash["Env 12"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4c"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4c"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["A4c Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A4c 4kb"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 without SX1 to A4c 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["A4c Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4a 4kb")
        sortHash["Env 15"] += 1
        sortHash["Env Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A4a"] += 1
        sortHash["SX2 to A4a"] += 1
        sortHash["A4a Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4a Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX1 to SX2 to A4a 4kb"] += 1
        sortHash["SX2 to A4a 4kb"] += 1
        sortHash["A4a Total 4kb"] += 1
        sortHash["A4a Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4c 4kb")
        sortHash["Env 9"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4c Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A4c"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A1 Total"] += 1
        sortHash["A4c Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4c Total 4kb"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 to A4c 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["A4c Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1




    elsif spliceMap.join(" ").eql?("D1 A5b 4kb")
        sortHash["Env 17"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["A5b Direct"] += 1
        sortHash["A5 Direct Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 4kb"] += 1
        sortHash["A5b Direct 4kb"] += 1
        sortHash["A5 Direct Total 4kb"] += 1
        sortHash["4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A2 D3 A5b 4kb")
        sortHash["Env 19"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5b"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A5b"] += 1
        sortHash["A5b Indirect"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A5b 4kb"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 without SX1 to A5b 4kb"] += 1
        sortHash["A5b Indirect 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["4kb"] += 1




    elsif spliceMap.join(" ").eql?("D1 A1 D2 A5b 4kb")
        sortHash["Env 18"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 to A5b"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["A5b Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 4kb"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 to A5b 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["A5b Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A5b 4kb")
        sortHash["Env 20"] += 1
        sortHash["Env Total"] += 1
        sortHash["A5b Total"] += 1
        sortHash["A5 Total"] += 1
        sortHash["A5 Indirect Total"] += 1
        sortHash["A5 Total 4kb"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A5b"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A5b"] += 1
        sortHash["A5b Indirect"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A5b Total 4kb"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A5b 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX1 to SX2 to A5b 4kb"] += 1
        sortHash["A5b Indirect 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A4d 4kb")
        sortHash["Env d"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["A4d Direct"] += 1
        sortHash["A4 Direct Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 4kb"] += 1
        sortHash["A4d Direct 4kb"] += 1
        sortHash["A4 Direct Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A4d 4kb")
        sortHash["Env d1"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX1 without SX2"] += 1
        sortHash["SX1 to A4d"] += 1
        sortHash["A4d Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 4kb"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX1 without SX2 4kb"] += 1
        sortHash["SX1 to A4d 4kb"] += 1
        sortHash["A4d Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1



    elsif spliceMap.join(" ").eql?("D1 A2 D3 A4d 4kb")
        sortHash["Env d2"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4d"] += 1
        sortHash["SX2 without SX1"] += 1
        sortHash["SX2 without SX1 to A4d"] += 1
        sortHash["A4d Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Direct"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A4d 4kb"] += 1
        sortHash["SX2 without SX1 4kb"] += 1
        sortHash["SX2 without SX1 to A4d 4kb"] += 1
        sortHash["A4d Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Direct 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1


    elsif spliceMap.join(" ").eql?("D1 A1 D2 A2 D3 A4d 4kb")
        sortHash["Env d12"] += 1
        sortHash["Env Total"] += 1
        sortHash["A4d Total"] += 1
        sortHash["A4 Total"] += 1
        sortHash["SX1 Total"] += 1
        sortHash["SX2 Total"] += 1
        sortHash["SX2 to A4d"] += 1
        sortHash["SX1 to SX2"] += 1
        sortHash["SX1 to SX2 to A4d"] += 1
        sortHash["A4d Indirect"] += 1
        sortHash["A4 Indirect Total"] += 1
        sortHash["A2 Total"] += 1
        sortHash["A2 Indirect"] += 1
        sortHash["A1 Total"] += 1
        sortHash["Good Reads"] += 1
        sortHash["A4d Total 4kb"] += 1
        sortHash["SX1 Total 4kb"] += 1
        sortHash["SX2 Total 4kb"] += 1
        sortHash["SX2 to A4d 4kb"] += 1
        sortHash["SX1 to SX2 4kb"] += 1
        sortHash["SX1 to SX2 to A4d 4kb"] += 1
        sortHash["A4d Indirect 4kb"] += 1
        sortHash["A4 Indirect Total 4kb"] += 1
        sortHash["A2 Total 4kb"] += 1
        sortHash["A2 Indirect 4kb"] += 1
        sortHash["A1 Total 4kb"] += 1
        sortHash["4kb"] += 1
        sortHash["A4 Total 4kb"] += 1




        #### Cryptic D2b


    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 Vpr 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 Vpr"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 Vpr 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A3 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A3"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A3 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4a 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A4a 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4b 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A4b 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4c 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4c"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A4c 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A4d 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A4d"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A4d 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A5a 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A5a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A5a 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A5b 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A5b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A5b 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A3 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A3"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A3 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4a 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4a 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4b 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4b 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4c 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4c"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4c 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A4d 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A4d"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A4d 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A5a 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A5a"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A5a 4kb"] += 1
        sortHash["4kb Cryptic"] += 1

    elsif spliceMap.join(" ").eql?("D1 A1 D2b A2 D3 A5b 4kb")
        sortHash["D2b"] += 1
        sortHash["D1 A1 D2b A2 D3 A5b"] += 1
        sortHash["Cryptic Reads"] += 1
        sortHash["D2b 4kb"] += 1
        sortHash["D1 A1 D2b A2 D3 A5b 4kb"] += 1
        sortHash["4kb Cryptic"] += 1


    else
        sortHash["Bad Reads"] += 1
        oddballs << spliceMap.join(" ")
        #print spliceMap.join(" ")
        #puts


    end



end

printArray =  sortHash.keys().sort()
#print printArray









outputFile = forwardFile + "_output_2023_06_CommonKmer.txt"

writeOut = File.open(outputFile, "w")

importantPiece = forwardFile.split("_")[0]
writeOut.write("\t" + importantPiece + "\n")
reads = (line_count/4)
writeOut.write("Reads\t" + reads.to_s)
writeOut.write("\n")

writeOut.write("Good Reads\t")
goodReads = sortHash["Good Reads"]
writeOut.write(goodReads.to_s + "\n")
writeOut.write("Bad Reads\t")
badReads = sortHash["Bad Reads"]
writeOut.write(badReads.to_s + "\n")


writeOut.write("\n\n\n\n")


writeOut.write("ALL TRANSCRIPTS\nPercent of Good Reads\n")
unspliced = sortHash["unspliced"]
writeOut.write("Unspliced\t" + unspliced.to_s + "\t" + (100.0*unspliced/goodReads).to_s + "\n")
incompletelySpliced = sortHash["4kb"]
writeOut.write("Incompletely Spliced\t" + incompletelySpliced.to_s + "\t" + (100.0*incompletelySpliced/goodReads).to_s + "\n")
completelySpliced = sortHash["1.8kb"]
writeOut.write("Completely Spliced\t" + completelySpliced.to_s + "\t" + (100.0*completelySpliced/goodReads).to_s + "\n")
allSplicedReads = incompletelySpliced + completelySpliced
writeOut.write("Completely Spliced Percentage of Spliced\t" + (100.0*completelySpliced/allSplicedReads).to_s + "\n")

#######
#######
#######

writeOut.write("\nALL TRANSCRIPTS \nPercent of All Transcripts\n")



#For All Spliced Reads:

allTranscriptsPrintArray = [ "unspliced", "A1 Total", "A2 Direct", "A3 Direct", "A4 Direct Total", "A5 Direct Total","Vif Total","Vpr Total", "Tat Total", "Tat Total 1.8kb", "Tat Total 4kb" , "Rev Total", "Nef Total", "Env Total","A1 Final","A2 Direct and Final", "A2 Indirect", "A2 Indirect and Final", "A2 Total", "A2 Final", "A3 Indirect",  "A3 Total","A4a Direct", "A4a Indirect", "A4a Total","A4b Direct", "A4b Indirect", "A4b Total","A4c Direct", "A4c Indirect", "A4c Total","A4d Direct", "A4d Indirect", "A4d Total","A4 Indirect Total", "A4 Total","A5a Direct", "A5a Indirect", "A5a Total","A5b Direct", "A5b Indirect", "A5b Total","A5 Indirect Total",  "A5 Total","SX1 Total", "SX2 Total", "SX1 to SX2", "SX1 without SX2", "SX2 without SX1", "SX1 to A2", "SX1 to A3", "SX1 to A4a", "SX1 to A4b", "SX1 to A4c", "SX1 to A4d", "SX1 to A5a", "SX1 to A5b", "SX2 to A3", "SX2 to A4a", "SX2 to A4b", "SX2 to A4c", "SX2 to A4d", "SX2 to A5a", "SX2 to A5b", "SX2 without SX1 to A3", "SX2 without SX1 to A4a", "SX2 without SX1 to A4b", "SX2 without SX1 to A4c", "SX2 without SX1 to A4d", "SX2 without SX1 to A5a", "SX2 without SX1 to A5b", "SX1 to SX2 to A3", "SX1 to SX2 to A4a", "SX1 to SX2 to A4b", "SX1 to SX2 to A4c", "SX1 to SX2 to A4d", "SX1 to SX2 to A5a", "SX1 to SX2 to A5b", "Nef 1", "Nef 1.1", "Nef 1.2", "Nef 1.12", "A7 Total", "A7 Direct", "A7 Indirect", "SX1 to A7", "SX2 to A7", "SX1 to SX2 to A7"]
allTranscriptsPrintArray.each do |spliceType|
    writeOut.write(spliceType + "\t" + sortHash[spliceType].to_s + "\t" + (100.0*sortHash[spliceType]/goodReads).to_s + "\n")
end


#######
#######
#######



writeOut.write("\nSPLICED TRANSCRIPTS - BOTH SIZE CLASSES\nPercent of All Spliced Reads\n")



#For All Spliced Reads:

allSplicedPrintArray = [ "A1 Total", "A2 Direct", "A3 Direct", "A4 Direct Total", "A5 Direct Total","Vif Total","Vpr Total", "Tat Total", "Tat Total 1.8kb", "Tat Total 4kb" , "Rev Total", "Nef Total", "Env Total","A1 Final","A2 Direct and Final", "A2 Indirect", "A2 Indirect and Final", "A2 Total", "A2 Final", "A3 Indirect",  "A3 Total","A4a Direct", "A4a Indirect", "A4a Total","A4b Direct", "A4b Indirect", "A4b Total","A4c Direct", "A4c Indirect", "A4c Total","A4d Direct", "A4d Indirect", "A4d Total","A4 Indirect Total", "A4 Total","A5a Direct", "A5a Indirect", "A5a Total","A5b Direct", "A5b Indirect", "A5b Total","A5 Indirect Total",  "A5 Total","SX1 Total", "SX2 Total", "SX1 to SX2", "SX1 without SX2", "SX2 without SX1", "SX1 to A2", "SX1 to A3", "SX1 to A4a", "SX1 to A4b", "SX1 to A4c", "SX1 to A4d", "SX1 to A5a", "SX1 to A5b", "SX2 to A3", "SX2 to A4a", "SX2 to A4b", "SX2 to A4c", "SX2 to A4d", "SX2 to A5a", "SX2 to A5b", "SX2 without SX1 to A3", "SX2 without SX1 to A4a", "SX2 without SX1 to A4b", "SX2 without SX1 to A4c", "SX2 without SX1 to A4d", "SX2 without SX1 to A5a", "SX2 without SX1 to A5b", "SX1 to SX2 to A3", "SX1 to SX2 to A4a", "SX1 to SX2 to A4b", "SX1 to SX2 to A4c", "SX1 to SX2 to A4d", "SX1 to SX2 to A5a", "SX1 to SX2 to A5b", "Nef 1", "Nef 1.1", "Nef 1.2", "Nef 1.12", "A7 Total", "A7 Direct", "A7 Indirect", "SX1 to A7", "SX2 to A7", "SX1 to SX2 to A7"]
allSplicedPrintArray.each do |spliceType|
    writeOut.write(spliceType + "\t" + sortHash[spliceType].to_s + "\t" + (100.0*sortHash[spliceType]/allSplicedReads).to_s + "\n")
end


#cryptics
writeOut.write("Cryptic Splices\n")
crypticArray = ["D2b", "D1 A1 D2b A2", "D1 A1 D2b A2 Vpr", "D1 A1 D2b A3", "D1 A1 D2b A4a", "D1 A1 D2b A4b", "D1 A1 D2b A4c", "D1 A1 D2b A4d", "D1 A1 D2b A5a", "D1 A1 D2b A5b", "D1 A1 D2b A2 D3 A3", "D1 A1 D2b A2 D3 A4a", "D1 A1 D2b A2 D3 A4b", "D1 A1 D2b A2 D3 A4c", "D1 A1 D2b A2 D3 A4d", "D1 A1 D2b A2 D3 A5a", "D1 A1 D2b A2 D3 A5b"]




crypticArray.each do |crypticSplice|
    writeOut.write(crypticSplice + "\t" + sortHash[crypticSplice].to_s + "\t" + (100.0*sortHash[crypticSplice]/completelySpliced).to_s + "\n")
end



#For 4KB reads

#combined by final acceptor
#4kb class

writeOut.write("\n4KB TRANSCRIPTS\nPercent of All 4KB Transcripts\n")
writeOut.write("D1 A5b Env17\t" + sortHash["Env 17"].to_s + "\t" + (100.0*sortHash["Env 17"]/incompletelySpliced).to_s   + "\n")
writeOut.write("D1 A1 D2 A5b Env18\t" + sortHash["Env 18"].to_s + "\t" + (100.0*sortHash["Env 18"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A5b Env19\t" + sortHash["Env 19"].to_s + "\t" + (100.0*sortHash["Env 19"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A5b Env20\t" + sortHash["Env 20"].to_s + "\t" + (100.0*sortHash["Env 20"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A5a Env1\t" + sortHash["Env 1"].to_s + "\t" + (100.0*sortHash["Env 1"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A5a Env5\t" + sortHash["Env 5"].to_s + "\t" + (100.0*sortHash["Env 5"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A5a Env8\t" + sortHash["Env 8"].to_s + "\t" + (100.0*sortHash["Env 8"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A5a Env13\t" + sortHash["Env 13"].to_s + "\t" + (100.0*sortHash["Env 13"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A4b Env2\t" + sortHash["Env 2"].to_s + "\t" + (100.0*sortHash["Env 2"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4b Env6\t" + sortHash["Env 6"].to_s + "\t" + (100.0*sortHash["Env 6"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4b Env10\t" + sortHash["Env 10"].to_s + "\t" + (100.0*sortHash["Env 10"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4b Env14\t" + sortHash["Env 14"].to_s + "\t" + (100.0*sortHash["Env 14"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A4a Env3\t" + sortHash["Env 3"].to_s + "\t" + (100.0*sortHash["Env 3"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4a Env7\t" + sortHash["Env 7"].to_s + "\t" + (100.0*sortHash["Env 7"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4a Env11\t" + sortHash["Env 11"].to_s + "\t" + (100.0*sortHash["Env 11"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4a Env15\t" + sortHash["Env 15"].to_s + "\t" + (100.0*sortHash["Env 15"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A4c Env4\t" + sortHash["Env 4"].to_s + "\t" + (100.0*sortHash["Env 4"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4c Env9\t" + sortHash["Env 9"].to_s + "\t" + (100.0*sortHash["Env 9"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4c Env12\t" + sortHash["Env 12"].to_s + "\t" + (100.0*sortHash["Env 12"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4c Env16\t" + sortHash["Env 16"].to_s + "\t" + (100.0*sortHash["Env 16"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A4d EnvD\t" + sortHash["Env d"].to_s + "\t" + (100.0*sortHash["Env d"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4d EnvD1\t" + sortHash["Env d1"].to_s + "\t" + (100.0*sortHash["Env d1"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4d EnvD2\t" + sortHash["Env d2"].to_s + "\t" + (100.0*sortHash["Env d2"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4d EnvD12\t" + sortHash["Env d12"].to_s + "\t" + (100.0*sortHash["Env d12"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A3 Tat5\t" + sortHash["Tat 5"].to_s + "\t" + (100.0*sortHash["Tat 5"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A3 Tat6\t" + sortHash["Tat 6"].to_s + "\t" + (100.0*sortHash["Tat 6"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A3 Tat7\t" + sortHash["Tat 7"].to_s + "\t" + (100.0*sortHash["Tat 7"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A3 Tat8\t" + sortHash["Tat 8"].to_s + "\t" + (100.0*sortHash["Tat 8"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A2 Vpr3\t" + sortHash["Vpr 3"].to_s + "\t" + (100.0*sortHash["Vpr 3"]/incompletelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 Vpr4\t" + sortHash["Vpr 4"].to_s + "\t" + (100.0*sortHash["Vpr 4"]/incompletelySpliced).to_s + "\n")

writeOut.write("D1 A1 Vif2\t" + sortHash["Vif 2"].to_s + "\t" + (100.0*sortHash["Vif 2"]/incompletelySpliced).to_s + "\n")






printArray = ["Env 1", "Env 2", "Env 3", "Env 4", "Env 5", "Env 6", "Env 7", "Env 8", "Env 9", "Env 10", "Env 11", "Env 12", "Env 13", "Env 14", "Env 15", "Env 16", "Env 17", "Env 18", "Env 19", "Env 20", "Env d", "Env d1", "Env d2", "Env d12", "Env e", "Env e1", "Env e2", "Env e12", "Env Total", "Tat 5", "Tat 6", "Tat 7", "Tat 8", "Tat Total 4kb", "Vif 2", "Vif Total 4kb", "Vpr 3", "Vpr 4", "Vpr Total 4kb",  "A1 Total 4kb", "A2 Direct 4kb", "A3 Direct 4kb", "A4 Direct Total 4kb", "A5 Direct Total 4kb","A1 Final 4kb","A2 Direct and Final 4kb", "A2 Indirect 4kb", "A2 Indirect and Final 4kb", "A2 Total 4kb", "A2 Final 4kb", "A3 Indirect 4kb",  "A3 Total 4kb","A4a Direct 4kb", "A4a Indirect 4kb", "A4a Total 4kb","A4b Direct 4kb", "A4b Indirect 4kb", "A4b Total 4kb","A4c Direct 4kb", "A4c Indirect 4kb", "A4c Total 4kb","A4d Direct 4kb", "A4d Indirect 4kb", "A4d Total 4kb","A4 Indirect Total 4kb", "A4 Total 4kb","A5a Direct 4kb", "A5a Indirect 4kb", "A5a Total 4kb","A5b Direct 4kb", "A5b Indirect 4kb", "A5b Total 4kb","A5 Indirect Total 4kb",  "A5 Total 4kb","SX1 Total 4kb", "SX2 Total 4kb", "SX1 to SX2 4kb", "SX1 without SX2 4kb", "SX2 without SX1 4kb", "SX1 to A2 4kb", "SX1 to A3 4kb", "SX1 to A4a 4kb", "SX1 to A4b 4kb", "SX1 to A4c 4kb", "SX1 to A4d 4kb", "SX1 to A5a 4kb", "SX1 to A5b 4kb", "SX2 to A3 4kb", "SX2 to A4a 4kb", "SX2 to A4b 4kb", "SX2 to A4c 4kb", "SX2 to A4d 4kb", "SX2 to A5a 4kb", "SX2 to A5b 4kb", "SX2 without SX1 to A3 4kb", "SX2 without SX1 to A4a 4kb", "SX2 without SX1 to A4b 4kb", "SX2 without SX1 to A4c 4kb", "SX2 without SX1 to A4d 4kb", "SX2 without SX1 to A5a 4kb", "SX2 without SX1 to A5b 4kb", "SX1 to SX2 to A3 4kb", "SX1 to SX2 to A4a 4kb", "SX1 to SX2 to A4b 4kb", "SX1 to SX2 to A4c 4kb", "SX1 to SX2 to A4d 4kb", "SX1 to SX2 to A5a 4kb", "SX1 to SX2 to A5b 4kb"]
printArray.each do |spliceType|
    writeOut.write(spliceType + "\t" + sortHash[spliceType].to_s + "\t" + (100.0*sortHash[spliceType]/incompletelySpliced).to_s + "\n")
end


#cryptics
writeOut.write("Cryptic Splices\n")
crypticArray = ["D2b 4kb", "D1 A1 D2b A2 4kb", "D1 A1 D2b A2 Vpr 4kb", "D1 A1 D2b A3 4kb", "D1 A1 D2b A4a 4kb", "D1 A1 D2b A4b 4kb", "D1 A1 D2b A4c 4kb", "D1 A1 D2b A4d 4kb", "D1 A1 D2b A5a 4kb", "D1 A1 D2b A5b 4kb", "D1 A1 D2b A2 D3 A3 4kb", "D1 A1 D2b A2 D3 A4a 4kb", "D1 A1 D2b A2 D3 A4b 4kb", "D1 A1 D2b A2 D3 A4c 4kb", "D1 A1 D2b A2 D3 A4d 4kb", "D1 A1 D2b A2 D3 A5a 4kb", "D1 A1 D2b A2 D3 A5b 4kb"]




crypticArray.each do |crypticSplice|
    writeOut.write(crypticSplice + "\t" + sortHash[crypticSplice].to_s + "\t" + (100.0*sortHash[crypticSplice]/completelySpliced).to_s + "\n")
end






#for 1.8KB reads



writeOut.write("\n1.8KB TRANSCRIPTS\nPercent of All 1.8KB Transcripts\n")
writeOut.write("D1 A5b Nef6\t" + sortHash["Nef 6"].to_s + "\t" + (100.0*sortHash["Nef 6"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A5b Nef7\t" + sortHash["Nef 7"].to_s + "\t" + (100.0*sortHash["Nef 7"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A5b Nef8\t" + sortHash["Nef 8"].to_s + "\t" + (100.0*sortHash["Nef 8"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A5b Nef9\t" + sortHash["Nef 9"].to_s + "\t" + (100.0*sortHash["Nef 9"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A5a Nef2\t" + sortHash["Nef 2"].to_s + "\t" + (100.0*sortHash["Nef 2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A5a Nef3\t" + sortHash["Nef 3"].to_s + "\t" + (100.0*sortHash["Nef 3"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A5a Nef4\t" + sortHash["Nef 4"].to_s + "\t" + (100.0*sortHash["Nef 4"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A5a Nef5\t" + sortHash["Nef 5"].to_s + "\t" + (100.0*sortHash["Nef 5"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A4b Rev1\t" + sortHash["Rev 1"].to_s + "\t" + (100.0*sortHash["Rev 1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4b Rev4\t" + sortHash["Rev 4"].to_s + "\t" + (100.0*sortHash["Rev 4"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4b Rev7\t" + sortHash["Rev 7"].to_s + "\t" + (100.0*sortHash["Rev 7"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4b Rev10\t" + sortHash["Rev 10"].to_s + "\t" + (100.0*sortHash["Rev 10"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A4a Rev2\t" + sortHash["Rev 2"].to_s + "\t" + (100.0*sortHash["Rev 2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4a Rev5\t" + sortHash["Rev 5"].to_s + "\t" + (100.0*sortHash["Rev 5"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4a Rev8\t" + sortHash["Rev 8"].to_s + "\t" + (100.0*sortHash["Rev 8"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4a Rev11\t" + sortHash["Rev 11"].to_s + "\t" + (100.0*sortHash["Rev 11"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A4c Rev3\t" + sortHash["Rev 3"].to_s + "\t" + (100.0*sortHash["Rev 3"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4c Rev6\t" + sortHash["Rev 6"].to_s + "\t" + (100.0*sortHash["Rev 6"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4c Rev9\t" + sortHash["Rev 9"].to_s + "\t" + (100.0*sortHash["Rev 9"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4c Rev12\t" + sortHash["Rev 12"].to_s + "\t" + (100.0*sortHash["Rev 12"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A4d RevD\t" + sortHash["Rev d"].to_s + "\t" + (100.0*sortHash["Rev d"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4d RevD1\t" + sortHash["Rev d1"].to_s + "\t" + (100.0*sortHash["Rev d1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4d RevD2\t" + sortHash["Rev d2"].to_s + "\t" + (100.0*sortHash["Rev d2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4d RevD12\t" + sortHash["Rev d12"].to_s + "\t" + (100.0*sortHash["Rev d12"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A3 Tat1\t" + sortHash["Tat 1"].to_s + "\t" + (100.0*sortHash["Tat 1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A3 Tat2\t" + sortHash["Tat 2"].to_s + "\t" + (100.0*sortHash["Tat 2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A3 Tat3\t" + sortHash["Tat 3"].to_s + "\t" + (100.0*sortHash["Tat 3"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A3 Tat4\t" + sortHash["Tat 4"].to_s + "\t" + (100.0*sortHash["Tat 4"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A2 Vpr1\t" + sortHash["Vpr 1"].to_s + "\t" + (100.0*sortHash["Vpr 1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 Vpr2\t" + sortHash["Vpr 2"].to_s + "\t" + (100.0*sortHash["Vpr 2"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A1 Vif1\t" + sortHash["Vif 1"].to_s + "\t" + (100.0*sortHash["Vif 1"]/completelySpliced).to_s + "\n")




#combined by direct or small exon



writeOut.write("D1 A5b Nef6\t" + sortHash["Nef 6"].to_s + "\t" + (100.0*sortHash["Nef 6"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A5a Nef2\t" + sortHash["Nef 2"].to_s + "\t" + (100.0*sortHash["Nef 2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A4b Rev1\t" + sortHash["Rev 1"].to_s + "\t" + (100.0*sortHash["Rev 1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A4a Rev2\t" + sortHash["Rev 2"].to_s + "\t" + (100.0*sortHash["Rev 2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A4c Rev3\t" + sortHash["Rev 3"].to_s + "\t" + (100.0*sortHash["Rev 3"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A4d RevD\t" + sortHash["Rev d"].to_s + "\t" + (100.0*sortHash["Rev d"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A3 Tat1\t" + sortHash["Tat 1"].to_s + "\t" + (100.0*sortHash["Tat 1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 Vpr1\t" + sortHash["Vpr 1"].to_s + "\t" + (100.0*sortHash["Vpr 1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 Vif1\t" + sortHash["Vif 1"].to_s + "\t" + (100.0*sortHash["Vif 1"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A1 D2 A5b Nef7\t" + sortHash["Nef 7"].to_s + "\t" + (100.0*sortHash["Nef 7"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A5a Nef3\t" + sortHash["Nef 3"].to_s + "\t" + (100.0*sortHash["Nef 3"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4b Rev4\t" + sortHash["Rev 4"].to_s + "\t" + (100.0*sortHash["Rev 4"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4a Rev5\t" + sortHash["Rev 5"].to_s + "\t" + (100.0*sortHash["Rev 5"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4c Rev6\t" + sortHash["Rev 6"].to_s + "\t" + (100.0*sortHash["Rev 6"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A4d RevD1\t" + sortHash["Rev d1"].to_s + "\t" + (100.0*sortHash["Rev d1"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A3 Tat2\t" + sortHash["Tat 2"].to_s + "\t" + (100.0*sortHash["Tat 2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 Vpr2\t" + sortHash["Vpr 2"].to_s + "\t" + (100.0*sortHash["Vpr 2"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A2 D3 A5b Nef8\t" + sortHash["Nef 8"].to_s + "\t" + (100.0*sortHash["Nef 8"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A5a Nef4\t" + sortHash["Nef 4"].to_s + "\t" + (100.0*sortHash["Nef 4"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4b Rev7\t" + sortHash["Rev 7"].to_s + "\t" + (100.0*sortHash["Rev 7"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4a Rev8\t" + sortHash["Rev 8"].to_s + "\t" + (100.0*sortHash["Rev 8"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4c Rev9\t" + sortHash["Rev 9"].to_s + "\t" + (100.0*sortHash["Rev 9"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A4d RevD2\t" + sortHash["Rev d2"].to_s + "\t" + (100.0*sortHash["Rev d2"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A2 D3 A3 Tat3\t" + sortHash["Tat 3"].to_s + "\t" + (100.0*sortHash["Tat 3"]/completelySpliced).to_s + "\n")

writeOut.write("D1 A1 D2 A2 D3 A5b Nef9\t" + sortHash["Nef 9"].to_s + "\t" + (100.0*sortHash["Nef 9"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A5a Nef5\t" + sortHash["Nef 5"].to_s + "\t" + (100.0*sortHash["Nef 5"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4b Rev10\t" + sortHash["Rev 10"].to_s + "\t" + (100.0*sortHash["Rev 10"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4a Rev11\t" + sortHash["Rev 11"].to_s + "\t" + (100.0*sortHash["Rev 11"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4c Rev12\t" + sortHash["Rev 12"].to_s + "\t" + (100.0*sortHash["Rev 12"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A4d RevD12\t" + sortHash["Rev d12"].to_s + "\t" + (100.0*sortHash["Rev d12"]/completelySpliced).to_s + "\n")
writeOut.write("D1 A1 D2 A2 D3 A3 Tat4\t" + sortHash["Tat 4"].to_s + "\t" + (100.0*sortHash["Tat 4"]/completelySpliced).to_s + "\n")



printArray = ["Nef 2", "Nef 3", "Nef 4", "Nef 5", "Nef 6", "Nef 7", "Nef 8", "Nef 9", "Nef Total", "Rev 1", "Rev 2", "Rev 3", "Rev 4", "Rev 5", "Rev 6", "Rev 7", "Rev 8", "Rev 9", "Rev 10", "Rev 11", "Rev 12", "Rev Total", "Tat 1", "Tat 2", "Tat 3", "Tat 4", "Tat Total 1.8kb", "Vif 1", "Vpr 1", "Vpr 2", "Vpr Total 1.8kb",  "A1 Total 1.8kb", "A2 Direct 1.8kb", "A3 Direct 1.8kb", "A4 Direct Total 1.8kb", "A5 Direct Total 1.8kb","A1 Final 1.8kb","A2 Direct and Final 1.8kb", "A2 Indirect 1.8kb", "A2 Indirect and Final 1.8kb", "A2 Total 1.8kb", "A2 Final 1.8kb", "A3 Indirect 1.8kb",  "A3 Total 1.8kb","A4a Direct 1.8kb", "A4a Indirect 1.8kb", "A4a Total 1.8kb","A4b Direct 1.8kb", "A4b Indirect 1.8kb", "A4b Total 1.8kb","A4c Direct 1.8kb", "A4c Indirect 1.8kb", "A4c Total 1.8kb","A4d Direct 1.8kb", "A4d Indirect 1.8kb", "A4d Total 1.8kb","A4 Indirect Total 1.8kb", "A4 Total 1.8kb","A5a Direct 1.8kb", "A5a Indirect 1.8kb", "A5a Total 1.8kb","A5b Direct 1.8kb", "A5b Indirect 1.8kb", "A5b Total 1.8kb","A5 Indirect Total 1.8kb",  "A5 Total 1.8kb","SX1 Total 1.8kb", "SX2 Total 1.8kb", "SX1 to SX2 1.8kb", "SX1 without SX2 1.8kb", "SX2 without SX1 1.8kb", "SX1 to A2 1.8kb", "SX1 to A3 1.8kb", "SX1 to A4a 1.8kb", "SX1 to A4b 1.8kb", "SX1 to A4c 1.8kb", "SX1 to A4d 1.8kb", "SX1 to A5a 1.8kb", "SX1 to A5b 1.8kb", "SX2 to A3 1.8kb", "SX2 to A4a 1.8kb", "SX2 to A4b 1.8kb", "SX2 to A4c 1.8kb", "SX2 to A4d 1.8kb", "SX2 to A5a 1.8kb", "SX2 to A5b 1.8kb", "SX2 without SX1 to A3 1.8kb", "SX2 without SX1 to A4a 1.8kb", "SX2 without SX1 to A4b 1.8kb", "SX2 without SX1 to A4c 1.8kb", "SX2 without SX1 to A4d 1.8kb", "SX2 without SX1 to A5a 1.8kb", "SX2 without SX1 to A5b 1.8kb", "SX1 to SX2 to A3 1.8kb", "SX1 to SX2 to A4a 1.8kb", "SX1 to SX2 to A4b 1.8kb", "SX1 to SX2 to A4c 1.8kb", "SX1 to SX2 to A4d 1.8kb", "SX1 to SX2 to A5a 1.8kb", "SX1 to SX2 to A5b 1.8kb"]
printArray.each do |spliceType|
    writeOut.write(spliceType + "\t" + sortHash[spliceType].to_s + "\t" +  (100.0*sortHash[spliceType]/completelySpliced).to_s + "\n")
end




#cryptics
writeOut.write("Cryptic Splices\n")
crypticArray = ["D2b 1.8kb", "D1 A1 D2b A2 1.8kb", "D1 A1 D2b A2 Vpr 1.8kb", "D1 A1 D2b A3 1.8kb", "D1 A1 D2b A4a 1.8kb", "D1 A1 D2b A4b 1.8kb", "D1 A1 D2b A4c 1.8kb", "D1 A1 D2b A4d 1.8kb", "D1 A1 D2b A5a 1.8kb", "D1 A1 D2b A5b 1.8kb", "D1 A1 D2b A2 D3 A3 1.8kb", "D1 A1 D2b A2 D3 A4a 1.8kb", "D1 A1 D2b A2 D3 A4b 1.8kb", "D1 A1 D2b A2 D3 A4c 1.8kb", "D1 A1 D2b A2 D3 A4d 1.8kb", "D1 A1 D2b A2 D3 A5a 1.8kb", "D1 A1 D2b A2 D3 A5b 1.8kb"]




crypticArray.each do |crypticSplice|
    writeOut.write(crypticSplice + "\t" + sortHash[crypticSplice].to_s + "\t" + (100.0*sortHash[crypticSplice]/completelySpliced).to_s + "\n")
end


#puts sortHash.keys


writeOut.write("\n")
writeOut.write("oddballs:\n")
writeOut.write(oddballs.to_s)
writeOut.write("\n")
pidDistributionHash = Hash.new(0)
countIDHash.each do |pid, numberOfOccurances|
    pidDistributionHash[numberOfOccurances] += 1
    #if numberOfOccurances > 80
    #    puts pid
    #end
    # AGGTTGCATTACAT in 4 kb > 2000 part of the HIV specific sequence of reverse primers
    # GCAATTGGTACAAGin 1.8 kb > 80
end

#print pidDistributionHash
sortedDistributionKeys = pidDistributionHash.keys.sort
#print sortedDistributionKeys
writeOut.write("PID Distribution:\n")
sortedDistributionKeys.each do |numberOfTimesAPIDIsUsed|
    writeOut.write(numberOfTimesAPIDIsUsed.to_s + "\t" + pidDistributionHash[numberOfTimesAPIDIsUsed].to_s + "\n")
end

unknownAcceptorHash = Hash.new(0)
$unknownAcceptors.each do |arrayOfAs|
    if arrayOfAs[0] != "no index"
        unknownAcceptorHash[arrayOfAs] += 1
    end
end

sortedUnknownAcceptorKeys = unknownAcceptorHash.keys.sort
writeOut.write("Cryptic Acceptors:\n")
sortedUnknownAcceptorKeys.each do |aIdx|
    writeOut.write(aIdx.to_s + "\t" + unknownAcceptorHash[aIdx].to_s + "\n")
end

writeOut.write("\nGag Binding\n")
sortedGagBindingTallyKeys = $gagBindingTally.keys.sort
sortedGagBindingTallyKeys.each do |key|
    writeOut.write(key.to_s + "\t" + $gagBindingTally[key].to_s + "\t" + $gagBindingHash[key] + "\n")
end

writeOut.write("\nCompletely Spliced Binding\n")
sortedCompleteBindingTallyKeys = $completeBindTally.keys.sort
sortedCompleteBindingTallyKeys.each do |key|
    writeOut.write(key.to_s + "\t" + $completeBindTally[key].to_s + "\t" + $completeHash[key] + "\n")
end

writeOut.write("\nIncompletely Spliced Binding\n")
sortedIncompleteBindingTallyKeys = $incompBindTally.keys.sort
sortedIncompleteBindingTallyKeys.each do |key|
    writeOut.write(key.to_s + "\t" + $incompBindTally[key].to_s + "\t" + $incompHash[key] + "\n")
end



writeOut.write("\nExpected Size Class Priming\n")
allCompletePrimes = completeSpliceCompletePrimer + completeSpliceIncompletePrimer
allIncompletePrimes = incompleteSpliceCompletePrimer + incompleteSpliceIncompletePrimer
writeOut.write("completeSpliceCompletePrimer\t#{completeSpliceCompletePrimer}\n")
writeOut.write("completeSpliceIncompletePrimer\t#{completeSpliceIncompletePrimer}\n")
writeOut.write("incompleteSpliceIncompletePrimer\t#{incompleteSpliceIncompletePrimer}\n")
writeOut.write("incompleteSpliceCompletePrimer\t#{incompleteSpliceCompletePrimer}\n")
writeOut.write("Percent 1.8kb with expected primer\t#{100.0*completeSpliceCompletePrimer/allCompletePrimes}\n")
writeOut.write("Percent 4kb with expected primer\t#{100.0*incompleteSpliceIncompletePrimer/allIncompletePrimes}\n")


writeOut.write("\nGagBindingChartData\n")
for i in 744..1344
    writeOut.write(i.to_s + "\t" + $gagBindingTally[i].to_s + "\n")
end

writeOut.write("\nCompletelySplicedBindingChartData\n")
for i in 8369..8969
    writeOut.write(i.to_s + "\t" + $completeBindTally[i].to_s + "\n")
end

writeOut.write("\nIncompletelySplicedBindingChartData\n")
for i in 6045..6645
    writeOut.write(i.to_s + "\t" + $incompBindTally[i].to_s + "\n")
end
